// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;
import ballerina/mime;

# Supabase API generated from the OpenAPI specification.<br>Visit [https://supabase.com/docs](https://supabase.com/docs) for a complete documentation.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl) returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get database branch config
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/branches/[BranchIdOrRef branchIdOrRef](map<string|string[]> headers = {}) returns BranchDetailResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a database branch
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/branches/[BranchIdOrRef1 branchIdOrRef](map<string|string[]> headers = {}) returns BranchDeleteResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update database branch config
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/branches/[BranchIdOrRef2 branchIdOrRef](UpdateBranchBody payload, map<string|string[]> headers = {}) returns BranchResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Pushes a database branch
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/branches/[BranchIdOrRef3 branchIdOrRef]/push(BranchActionBody payload, map<string|string[]> headers = {}) returns BranchUpdateResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}/push`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Merges a database branch
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/branches/[BranchIdOrRef4 branchIdOrRef]/merge(BranchActionBody payload, map<string|string[]> headers = {}) returns BranchUpdateResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}/merge`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Resets a database branch
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/branches/[BranchIdOrRef5 branchIdOrRef]/reset(BranchActionBody payload, map<string|string[]> headers = {}) returns BranchUpdateResponse|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}/reset`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Diffs a database branch
    #
    # + branchIdOrRef - Branch ID
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/branches/[BranchIdOrRef6 branchIdOrRef]/diff(map<string|string[]> headers = {}, *V1DiffABranchQueries queries) returns string|error {
        string resourcePath = string `/v1/branches/${getEncodedUri(branchIdOrRef)}/diff`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # List all projects
    #
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects(map<string|string[]> headers = {}) returns V1ProjectWithDatabaseResponse[]|error {
        string resourcePath = string `/v1/projects`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a project
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects(V1CreateProjectBody payload, map<string|string[]> headers = {}) returns V1ProjectResponse|error {
        string resourcePath = string `/v1/projects`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Gets the list of available regions that can be used for a new project
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/available\-regions(map<string|string[]> headers = {}, *V1GetAvailableRegionsQueries queries) returns RegionsInfo|error {
        string resourcePath = string `/v1/projects/available-regions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # List all organizations
    #
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/organizations(map<string|string[]> headers = {}) returns OrganizationResponseV1[]|error {
        string resourcePath = string `/v1/organizations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create an organization
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/organizations(CreateOrganizationV1 payload, map<string|string[]> headers = {}) returns OrganizationResponseV1|error {
        string resourcePath = string `/v1/organizations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Authorize user through oauth
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/oauth/authorize(map<string|string[]> headers = {}, *V1AuthorizeUserQueries queries) returns error? {
        string resourcePath = string `/v1/oauth/authorize`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Exchange auth code for user's access and refresh token
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/oauth/token(OAuthTokenBody payload, map<string|string[]> headers = {}) returns OAuthTokenResponse|error {
        string resourcePath = string `/v1/oauth/token`;
        http:Request request = new;
        string encodedRequestBody = createFormURLEncodedRequestBody(check jsondata:toJson(payload).ensureType());
        request.setPayload(encodedRequestBody, "application/x-www-form-urlencoded");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Revoke oauth app authorization and it's corresponding tokens
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/oauth/revoke(OAuthRevokeTokenBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/oauth/revoke`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Authorize user through oauth and claim a project
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/oauth/authorize/project\-claim(map<string|string[]> headers = {}, *V1OauthAuthorizeProjectClaimQueries queries) returns error? {
        string resourcePath = string `/v1/oauth/authorize/project-claim`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Lists SQL snippets for the logged in user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/snippets(map<string|string[]> headers = {}, *V1ListAllSnippetsQueries queries) returns SnippetList|error {
        string resourcePath = string `/v1/snippets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets a specific SQL snippet
    #
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/snippets/[string id](map<string|string[]> headers = {}) returns SnippetResponse|error {
        string resourcePath = string `/v1/snippets/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List all action runs
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/actions(map<string|string[]> headers = {}, *V1ListActionRunsQueries queries) returns ListActionRunResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/actions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Count the number of action runs
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function head v1/projects/[string ref]/actions(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/actions`;
        return self.clientEp->head(resourcePath, headers);
    }

    # Get the status of an action run
    #
    # + ref - Project ref
    # + runId - Action Run ID
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/actions/[string runId](map<string|string[]> headers = {}) returns ActionRunResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/actions/${getEncodedUri(runId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update the status of an action run
    #
    # + ref - Project ref
    # + runId - Action Run ID
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/actions/[string runId]/status(UpdateRunStatusBody payload, map<string|string[]> headers = {}) returns UpdateRunStatusResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/actions/${getEncodedUri(runId)}/status`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Get the logs of an action run
    #
    # + ref - Project ref
    # + runId - Action Run ID
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/actions/[string runId]/logs(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/actions/${getEncodedUri(runId)}/logs`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get project api keys
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/api\-keys(map<string|string[]> headers = {}, *V1GetProjectApiKeysQueries queries) returns ApiKeyResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new API key for the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function post v1/projects/[string ref]/api\-keys(CreateApiKeyBody payload, map<string|string[]> headers = {}, *V1CreateProjectApiKeyQueries queries) returns ApiKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Check whether JWT based legacy (anon, service_role) API keys are enabled. This API endpoint will be removed in the future, check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/api\-keys/legacy(map<string|string[]> headers = {}) returns LegacyApiKeysResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys/legacy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Disable or re-enable JWT based legacy (anon, service_role) API keys. This API endpoint will be removed in the future, check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function put v1/projects/[string ref]/api\-keys/legacy(map<string|string[]> headers = {}, *V1UpdateProjectLegacyApiKeysQueries queries) returns LegacyApiKeysResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys/legacy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get API key
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/api\-keys/[string id](map<string|string[]> headers = {}, *V1GetProjectApiKeyQueries queries) returns ApiKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Deletes an API key for the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/api\-keys/[string id](map<string|string[]> headers = {}, *V1DeleteProjectApiKeyQueries queries) returns ApiKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Updates an API key for the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/api\-keys/[string id](UpdateApiKeyBody payload, map<string|string[]> headers = {}, *V1UpdateProjectApiKeyQueries queries) returns ApiKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/api-keys/${getEncodedUri(id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List all database branches
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/branches(map<string|string[]> headers = {}) returns BranchResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/branches`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a database branch
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/branches(CreateBranchBody payload, map<string|string[]> headers = {}) returns BranchResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/branches`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Disables preview branching
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/branches(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/branches`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Get a database branch
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/branches/[string name](map<string|string[]> headers = {}) returns BranchResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/branches/${getEncodedUri(name)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Gets project's custom hostname config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/custom\-hostname(map<string|string[]> headers = {}) returns UpdateCustomHostnameResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/custom-hostname`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Deletes a project's custom hostname configuration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/custom\-hostname(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/custom-hostname`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # [Beta] Updates project's custom hostname configuration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/custom\-hostname/initialize(UpdateCustomHostnameBody payload, map<string|string[]> headers = {}) returns UpdateCustomHostnameResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/custom-hostname/initialize`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Attempts to verify the DNS configuration for project's custom hostname configuration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/custom\-hostname/reverify(map<string|string[]> headers = {}) returns UpdateCustomHostnameResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/custom-hostname/reverify`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Activates a vanity subdomain for a project.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/custom\-hostname/activate(map<string|string[]> headers = {}) returns UpdateCustomHostnameResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/custom-hostname/activate`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Gets project's network bans
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/network\-bans/retrieve(map<string|string[]> headers = {}) returns NetworkBanResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-bans/retrieve`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Gets project's network bans with additional information about which databases they affect
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/network\-bans/retrieve/enriched(map<string|string[]> headers = {}) returns NetworkBanResponseEnriched|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-bans/retrieve/enriched`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Remove network bans.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/network\-bans(RemoveNetworkBanRequest payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-bans`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # [Beta] Gets project's network restrictions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/network\-restrictions(map<string|string[]> headers = {}) returns NetworkRestrictionsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-restrictions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Alpha] Updates project's network restrictions by adding or removing CIDRs
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/network\-restrictions(NetworkRestrictionsPatchRequest payload, map<string|string[]> headers = {}) returns NetworkRestrictionsV2Response|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-restrictions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # [Beta] Updates project's network restrictions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/network\-restrictions/apply(NetworkRestrictionsRequest payload, map<string|string[]> headers = {}) returns NetworkRestrictionsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/network-restrictions/apply`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Gets project's pgsodium config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/pgsodium(map<string|string[]> headers = {}) returns PgsodiumConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/pgsodium`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Updates project's pgsodium config. Updating the root_key can cause all data encrypted with the older key to become inaccessible.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/pgsodium(UpdatePgsodiumConfigBody payload, map<string|string[]> headers = {}) returns PgsodiumConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/pgsodium`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Gets project's postgrest config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/postgrest(map<string|string[]> headers = {}) returns PostgrestConfigWithJWTSecretResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/postgrest`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's postgrest config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/postgrest(V1UpdatePostgrestConfigBody payload, map<string|string[]> headers = {}) returns V1PostgrestConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/postgrest`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets a specific project that belongs to the authenticated user
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref](map<string|string[]> headers = {}) returns V1ProjectWithDatabaseResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Deletes the given project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref](map<string|string[]> headers = {}) returns V1ProjectRefResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List all secrets
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/secrets(map<string|string[]> headers = {}) returns SecretResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/secrets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk create secrets
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/secrets(CreateSecretBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/secrets`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk delete secrets
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/secrets(string[] payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/secrets`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->delete(resourcePath, request, headers);
    }

    # [Beta] Get project's SSL enforcement configuration.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/ssl\-enforcement(map<string|string[]> headers = {}) returns SslEnforcementResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/ssl-enforcement`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Update project's SSL enforcement configuration.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/ssl\-enforcement(SslEnforcementRequest payload, map<string|string[]> headers = {}) returns SslEnforcementResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/ssl-enforcement`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Generate TypeScript types
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/types/typescript(map<string|string[]> headers = {}, *V1GenerateTypescriptTypesQueries queries) returns TypescriptResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/types/typescript`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Gets current vanity subdomain config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/vanity\-subdomain(map<string|string[]> headers = {}) returns VanitySubdomainConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/vanity-subdomain`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Deletes a project's vanity subdomain configuration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/vanity\-subdomain(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/vanity-subdomain`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # [Beta] Checks vanity subdomain availability
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/vanity\-subdomain/check\-availability(VanitySubdomainBody payload, map<string|string[]> headers = {}) returns SubdomainAvailabilityResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/vanity-subdomain/check-availability`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Activates a vanity subdomain for a project.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/vanity\-subdomain/activate(VanitySubdomainBody payload, map<string|string[]> headers = {}) returns ActivateVanitySubdomainResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/vanity-subdomain/activate`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Upgrades the project's Postgres version
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/upgrade(UpgradeDatabaseBody payload, map<string|string[]> headers = {}) returns ProjectUpgradeInitiateResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/upgrade`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Returns the project's eligibility for upgrades
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/upgrade/eligibility(map<string|string[]> headers = {}) returns ProjectUpgradeEligibilityResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/upgrade/eligibility`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Gets the latest status of the project's upgrade
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/upgrade/status(map<string|string[]> headers = {}, *V1GetPostgresUpgradeStatusQueries queries) returns DatabaseUpgradeStatusResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/upgrade/status`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns project's readonly mode status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/'readonly(map<string|string[]> headers = {}) returns ReadOnlyStatusResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/readonly`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Disables project's readonly mode for the next 15 minutes
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/'readonly/temporary\-disable(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/readonly/temporary-disable`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Set up a read replica
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/read\-replicas/setup(SetUpReadReplicaBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/read-replicas/setup`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Remove a read replica
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/read\-replicas/remove(RemoveReadReplicaBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/read-replicas/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets project's service health status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/health(map<string|string[]> headers = {}, *V1GetServicesHealthQueries queries) returns V1ServiceHealthResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/health`;
        map<Encoding> queryParamEncoding = {"services": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get the signing key information for the JWT secret imported as signing key for this project. This endpoint will be removed in the future, check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys/legacy(map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/legacy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set up the project's existing JWT secret as an in_use JWT signing key. This endpoint will be removed in the future always check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/signing\-keys/legacy(map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/legacy`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List all signing keys for the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys(map<string|string[]> headers = {}) returns SigningKeysResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a new signing key for the project in standby status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/signing\-keys(CreateSigningKeyBody payload, map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a third-party integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys/[string id](map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Removes a third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/signing\-keys/[string id](map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update a signing key, mainly its status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/auth/signing\-keys/[string id](UpdateSigningKeyBody payload, map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets project's storage config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/storage(map<string|string[]> headers = {}) returns StorageConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/storage`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's storage config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/storage(UpdateStorageConfigBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/storage`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets project's Postgres config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/postgres(map<string|string[]> headers = {}) returns PostgresConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/postgres`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's Postgres config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/config/database/postgres(UpdatePostgresConfigBody payload, map<string|string[]> headers = {}) returns PostgresConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/postgres`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project's pgbouncer config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/pgbouncer(map<string|string[]> headers = {}) returns V1PgbouncerConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pgbouncer`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's supavisor config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/pooler(map<string|string[]> headers = {}) returns SupavisorConfigResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pooler`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's supavisor config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/database/pooler(UpdateSupavisorConfigBody payload, map<string|string[]> headers = {}) returns UpdateSupavisorConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pooler`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets project's auth config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth(map<string|string[]> headers = {}) returns AuthConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a project's auth config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/auth(UpdateAuthConfigBody payload, map<string|string[]> headers = {}) returns AuthConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Lists all third-party auth integrations
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/third\-party\-auth(map<string|string[]> headers = {}) returns ThirdPartyAuth[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/third\-party\-auth(CreateThirdPartyAuthBody payload, map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a third-party integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/third\-party\-auth/[string tpaId](map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth/${getEncodedUri(tpaId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Removes a third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/third\-party\-auth/[string tpaId](map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth/${getEncodedUri(tpaId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Pauses the given project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/pause(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/pause`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Lists available restore versions for the given project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/restore(map<string|string[]> headers = {}) returns GetProjectAvailableRestoreVersionsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/restore`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Restores the given project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/restore(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/restore`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Cancels the given project restoration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/restore/cancel(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/restore/cancel`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List billing addons and compute instance selections
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/billing/addons(map<string|string[]> headers = {}) returns ListProjectAddonsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Apply or update billing addons, including compute instance size
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/billing/addons(ApplyProjectAddonBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Remove billing addons or revert compute instance sizing
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/billing/addons/[AddonVariant addonVariant](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons/${getEncodedUri(addonVariant)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Gets project claim token
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/claim\-token(map<string|string[]> headers = {}) returns ProjectClaimTokenResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/claim-token`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates project claim token
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/claim\-token(map<string|string[]> headers = {}) returns CreateProjectClaimTokenResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/claim-token`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Revokes project claim token
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/claim\-token(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/claim-token`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Gets project performance advisors.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/advisors/performance(map<string|string[]> headers = {}) returns V1ProjectAdvisorsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/advisors/performance`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project security advisors.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/advisors/security(map<string|string[]> headers = {}, *V1GetSecurityAdvisorsQueries queries) returns V1ProjectAdvisorsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/advisors/security`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's logs
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/logs\.all(map<string|string[]> headers = {}, *V1GetProjectLogsQueries queries) returns AnalyticsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/logs.all`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's usage api counts
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/usage\.api\-counts(map<string|string[]> headers = {}, *V1GetProjectUsageApiCountQueries queries) returns V1GetUsageApiCountResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/usage.api-counts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's usage api requests count
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/usage\.api\-requests\-count(map<string|string[]> headers = {}) returns V1GetUsageApiRequestsCountResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/usage.api-requests-count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets a project's function combined statistics
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/functions\.combined\-stats(map<string|string[]> headers = {}, *V1GetProjectFunctionCombinedStatsQueries queries) returns AnalyticsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/functions.combined-stats`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Create a login role for CLI with temporary password
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/cli/login\-role(CreateRoleBody payload, map<string|string[]> headers = {}) returns CreateRoleResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/cli/login-role`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Delete existing login roles used by CLI
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/cli/login\-role(map<string|string[]> headers = {}) returns DeleteRolesResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/cli/login-role`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # [Beta] List applied migration versions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/migrations(map<string|string[]> headers = {}) returns V1ListMigrationsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Upsert a database migration without applying
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/database/migrations(V1UpsertMigrationBody payload, V1UpsertAMigrationHeaders headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # [Beta] Apply a database migration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/migrations(V1CreateMigrationBody payload, V1ApplyAMigrationHeaders headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # [Beta] Run sql query
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/query(V1RunQueryBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/query`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Enables Database Webhooks on the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/webhooks/enable(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/webhooks/enable`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets database metadata for the given project.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/database/context(map<string|string[]> headers = {}) returns GetProjectDbMetadataResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/context`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/jit(map<string|string[]> headers = {}) returns JitAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a user mapping for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/database/jit(UpdateJitAccessBody payload, map<string|string[]> headers = {}) returns JitAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Authorize user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/jit(AuthorizeJitAccessBody payload, map<string|string[]> headers = {}) returns JitAuthorizeAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List all user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/jit/list(map<string|string[]> headers = {}) returns JitListAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit/list`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete JIT access by user-id
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/database/jit/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit/${getEncodedUri(userId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List all functions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/functions(map<string|string[]> headers = {}) returns FunctionResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk update functions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/functions(BulkUpdateFunctionBody payload, map<string|string[]> headers = {}) returns BulkUpdateFunctionResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create a function
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post v1/projects/[string ref]/functions(http:Request request, map<string|string[]> headers = {}, *V1CreateAFunctionQueries queries) returns FunctionResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Deploy a function
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function post v1/projects/[string ref]/functions/deploy(FunctionDeployBody payload, map<string|string[]> headers = {}, *V1DeployAFunctionQueries queries) returns DeployFunctionResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions/deploy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        mime:Entity[] bodyParts = check createBodyParts(check jsondata:toJson(payload).ensureType());
        request.setBodyParts(bodyParts);
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Retrieve a function
    #
    # + ref - Project ref
    # + functionSlug - Function slug
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/functions/[string functionSlug](map<string|string[]> headers = {}) returns FunctionSlugResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions/${getEncodedUri(functionSlug)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete a function
    #
    # + ref - Project ref
    # + functionSlug - Function slug
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/functions/[string functionSlug](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions/${getEncodedUri(functionSlug)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update a function
    #
    # + ref - Project ref
    # + functionSlug - Function slug
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/functions/[string functionSlug](http:Request request, map<string|string[]> headers = {}, *V1UpdateAFunctionQueries queries) returns FunctionResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions/${getEncodedUri(functionSlug)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        // TODO: Update the request as needed;
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Retrieve a function body
    #
    # + ref - Project ref
    # + functionSlug - Function slug
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/functions/[string functionSlug]/body(map<string|string[]> headers = {}) returns StreamableFile|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/functions/${getEncodedUri(functionSlug)}/body`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Lists all buckets
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/storage/buckets(map<string|string[]> headers = {}) returns V1StorageBucketResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/storage/buckets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Lists all SSO providers
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/sso/providers(map<string|string[]> headers = {}) returns ListProvidersResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new SSO provider
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/sso/providers(CreateProviderBody payload, map<string|string[]> headers = {}) returns CreateProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/sso/providers/[string providerId](map<string|string[]> headers = {}) returns GetProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/config/auth/sso/providers/[string providerId](UpdateProviderBody payload, map<string|string[]> headers = {}) returns UpdateProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Removes a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/sso/providers/[string providerId](map<string|string[]> headers = {}) returns DeleteProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Lists all backups
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/backups(map<string|string[]> headers = {}) returns V1BackupsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Restores a PITR backup for a database
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/restore\-pitr(V1RestorePitrBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-pitr`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get restore points for project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/backups/restore\-point(map<string|string[]> headers = {}, *V1GetRestorePointQueries queries) returns V1RestorePointResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-point`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Initiates a creation of a restore point for a database
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/restore\-point(V1RestorePointPostBody payload, map<string|string[]> headers = {}) returns V1RestorePointResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-point`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Initiates an undo to a given restore point
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/undo(V1UndoBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/undo`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List members of an organization
    #
    # + slug - Organization slug
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/organizations/[string slug]/members(map<string|string[]> headers = {}) returns V1OrganizationMemberResponse[]|error {
        string resourcePath = string `/v1/organizations/${getEncodedUri(slug)}/members`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets information about the organization
    #
    # + slug - Organization slug
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/organizations/[string slug](map<string|string[]> headers = {}) returns V1OrganizationSlugResponse|error {
        string resourcePath = string `/v1/organizations/${getEncodedUri(slug)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project details for the specified organization and claim token
    #
    # + slug - Organization slug
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/organizations/[string slug]/project\-claim/[string token](map<string|string[]> headers = {}) returns OrganizationProjectClaimResponse|error {
        string resourcePath = string `/v1/organizations/${getEncodedUri(slug)}/project-claim/${getEncodedUri(token)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Claims project for the specified organization
    #
    # + slug - Organization slug
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/organizations/[string slug]/project\-claim/[string token](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/organizations/${getEncodedUri(slug)}/project-claim/${getEncodedUri(token)}`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets all projects for the given organization
    #
    # + slug - Organization slug
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/organizations/[string slug]/projects(map<string|string[]> headers = {}, *V1GetAllProjectsForOrganizationQueries queries) returns OrganizationProjectsResponse|error {
        string resourcePath = string `/v1/organizations/${getEncodedUri(slug)}/projects`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }
}
