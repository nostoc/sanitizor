// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# Supabase API generated from the OpenAPI specification.<br>Visit [https://supabase.com/docs](https://supabase.com/docs) for a complete documentation.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl) returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Lists SQL snippets for the logged in user
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/snippets(map<string|string[]> headers = {}, *V1ListAllSnippetsQueries queries) returns SnippetList|error {
        string resourcePath = string `/v1/snippets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets a specific SQL snippet
    #
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/snippets/[string id](map<string|string[]> headers = {}) returns SnippetResponse|error {
        string resourcePath = string `/v1/snippets/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Get project's SSL enforcement configuration.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/ssl\-enforcement(map<string|string[]> headers = {}) returns SslEnforcementResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/ssl-enforcement`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Update project's SSL enforcement configuration.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/ssl\-enforcement(SslEnforcementRequest payload, map<string|string[]> headers = {}) returns SslEnforcementResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/ssl-enforcement`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Generate TypeScript types
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/types/typescript(map<string|string[]> headers = {}, *V1GenerateTypescriptTypesQueries queries) returns TypescriptResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/types/typescript`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Returns project's readonly mode status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/'readonly(map<string|string[]> headers = {}) returns ReadOnlyStatusResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/readonly`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Disables project's readonly mode for the next 15 minutes
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/'readonly/temporary\-disable(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/readonly/temporary-disable`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Set up a read replica
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/read\-replicas/setup(SetUpReadReplicaBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/read-replicas/setup`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Remove a read replica
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/read\-replicas/remove(RemoveReadReplicaBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/read-replicas/remove`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get the signing key information for the JWT secret imported as signing key for this project. This endpoint will be removed in the future, check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys/legacy(map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/legacy`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Set up the project's existing JWT secret as an in_use JWT signing key. This endpoint will be removed in the future always check for HTTP 404 Not Found.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/signing\-keys/legacy(map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/legacy`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List all signing keys for the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys(map<string|string[]> headers = {}) returns SigningKeysResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create a new signing key for the project in standby status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/signing\-keys(CreateSigningKeyBody payload, map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a third-party integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/signing\-keys/[string id](map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Removes a third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/signing\-keys/[string id](map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update a signing key, mainly its status
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/auth/signing\-keys/[string id](UpdateSigningKeyBody payload, map<string|string[]> headers = {}) returns SigningKeyResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/signing-keys/${getEncodedUri(id)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets project's Postgres config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/postgres(map<string|string[]> headers = {}) returns PostgresConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/postgres`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's Postgres config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/config/database/postgres(UpdatePostgresConfigBody payload, map<string|string[]> headers = {}) returns PostgresConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/postgres`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Get project's pgbouncer config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/pgbouncer(map<string|string[]> headers = {}) returns V1PgbouncerConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pgbouncer`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's supavisor config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/database/pooler(map<string|string[]> headers = {}) returns SupavisorConfigResponse[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pooler`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates project's supavisor config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/database/pooler(UpdateSupavisorConfigBody payload, map<string|string[]> headers = {}) returns UpdateSupavisorConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/database/pooler`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Gets project's auth config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth(map<string|string[]> headers = {}) returns AuthConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a project's auth config
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/config/auth(UpdateAuthConfigBody payload, map<string|string[]> headers = {}) returns AuthConfigResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Lists all third-party auth integrations
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/third\-party\-auth(map<string|string[]> headers = {}) returns ThirdPartyAuth[]|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/third\-party\-auth(CreateThirdPartyAuthBody payload, map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get a third-party integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/third\-party\-auth/[string tpaId](map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth/${getEncodedUri(tpaId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Removes a third-party auth integration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/third\-party\-auth/[string tpaId](map<string|string[]> headers = {}) returns ThirdPartyAuth|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/third-party-auth/${getEncodedUri(tpaId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List billing addons and compute instance selections
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/billing/addons(map<string|string[]> headers = {}) returns ListProjectAddonsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Apply or update billing addons, including compute instance size
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function patch v1/projects/[string ref]/billing/addons(ApplyProjectAddonBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Remove billing addons or revert compute instance sizing
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/billing/addons/[AddonVariant addonVariant](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/billing/addons/${getEncodedUri(addonVariant)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Gets project performance advisors.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/advisors/performance(map<string|string[]> headers = {}) returns V1ProjectAdvisorsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/advisors/performance`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project security advisors.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/advisors/security(map<string|string[]> headers = {}, *V1GetSecurityAdvisorsQueries queries) returns V1ProjectAdvisorsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/advisors/security`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's logs
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/logs\.all(map<string|string[]> headers = {}, *V1GetProjectLogsQueries queries) returns AnalyticsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/logs.all`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's usage api counts
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/usage\.api\-counts(map<string|string[]> headers = {}, *V1GetProjectUsageApiCountQueries queries) returns V1GetUsageApiCountResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/usage.api-counts`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets project's usage api requests count
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/usage\.api\-requests\-count(map<string|string[]> headers = {}) returns V1GetUsageApiRequestsCountResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/usage.api-requests-count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Gets a project's function combined statistics
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/analytics/endpoints/functions\.combined\-stats(map<string|string[]> headers = {}, *V1GetProjectFunctionCombinedStatsQueries queries) returns AnalyticsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/analytics/endpoints/functions.combined-stats`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Create a login role for CLI with temporary password
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/cli/login\-role(CreateRoleBody payload, map<string|string[]> headers = {}) returns CreateRoleResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/cli/login-role`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Delete existing login roles used by CLI
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/cli/login\-role(map<string|string[]> headers = {}) returns DeleteRolesResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/cli/login-role`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # [Beta] List applied migration versions
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/migrations(map<string|string[]> headers = {}) returns V1ListMigrationsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # [Beta] Upsert a database migration without applying
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/database/migrations(V1UpsertMigrationBody payload, V1UpsertAMigrationHeaders headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # [Beta] Apply a database migration
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/migrations(V1CreateMigrationBody payload, V1ApplyAMigrationHeaders headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/migrations`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # [Beta] Run sql query
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/query(V1RunQueryBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/query`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # [Beta] Enables Database Webhooks on the project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/webhooks/enable(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/webhooks/enable`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets database metadata for the given project.
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get v1/projects/[string ref]/database/context(map<string|string[]> headers = {}) returns GetProjectDbMetadataResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/context`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/jit(map<string|string[]> headers = {}) returns JitAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a user mapping for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/database/jit(UpdateJitAccessBody payload, map<string|string[]> headers = {}) returns JitAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Authorize user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/jit(AuthorizeJitAccessBody payload, map<string|string[]> headers = {}) returns JitAuthorizeAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List all user-id to role mappings for JIT access
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/jit/list(map<string|string[]> headers = {}) returns JitListAccessResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit/list`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete JIT access by user-id
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/database/jit/[string userId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/jit/${getEncodedUri(userId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Lists all SSO providers
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/sso/providers(map<string|string[]> headers = {}) returns ListProvidersResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Creates a new SSO provider
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/config/auth/sso/providers(CreateProviderBody payload, map<string|string[]> headers = {}) returns CreateProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Gets a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/config/auth/sso/providers/[string providerId](map<string|string[]> headers = {}) returns GetProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Updates a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function put v1/projects/[string ref]/config/auth/sso/providers/[string providerId](UpdateProviderBody payload, map<string|string[]> headers = {}) returns UpdateProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Removes a SSO provider by its UUID
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function delete v1/projects/[string ref]/config/auth/sso/providers/[string providerId](map<string|string[]> headers = {}) returns DeleteProviderResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/config/auth/sso/providers/${getEncodedUri(providerId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Lists all backups
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/backups(map<string|string[]> headers = {}) returns V1BackupsResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Restores a PITR backup for a database
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/restore\-pitr(V1RestorePitrBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-pitr`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get restore points for project
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get v1/projects/[string ref]/database/backups/restore\-point(map<string|string[]> headers = {}, *V1GetRestorePointQueries queries) returns V1RestorePointResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-point`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # Initiates a creation of a restore point for a database
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/restore\-point(V1RestorePointPostBody payload, map<string|string[]> headers = {}) returns V1RestorePointResponse|error {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/restore-point`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Initiates an undo to a given restore point
    #
    # + ref - Project ref
    # + headers - Headers to be sent with the request 
    resource isolated function post v1/projects/[string ref]/database/backups/undo(V1UndoBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/v1/projects/${getEncodedUri(ref)}/database/backups/undo`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
