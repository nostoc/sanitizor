// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

# Welcome to the OpenAPI reference documentation for the Smartsheet API!
#
# > **IMPORTANT:**
# > * The Smartsheet API is restricted to users on Business and Enterprise plans
# > * The <a href="https://www.smartsheet.com/legal/developer-program-agreement" target="_blank" rel="noopener noreferrer">Developer Agreement</a> governs the use of the Smartsheet API and Smartsheet software development kits (SDKs)
#
# **QUICKLINKS**
#
# - **Base URL:**
#
# ```
#     https://api.smartsheet.com/2.0/
#
# ```
#
# - **Getting started:** <a href="https://help.smartsheet.com/articles/2482389-generate-API-key" target="_blank" rel="noopener noreferrer">Generate an API access token</a> and [make a request](/api/smartsheet/guides/getting-started).
#
# - **Changelog:** See the latest [API updates](/api/smartsheet/changelog).
#
# - **Schemas:** View the [object schemas](/api/smartsheet/openapi/schemas) not explicitly listed in the resource sections.
#
# - **Error codes:** Look up common API [error codes](/api/smartsheet/error-codes).
#
# - **Guides:** Learn various ways of using the API with the help of our [Guides](/api/smartsheet/introduction).
#
# Browse the Smartsheet API operations by resource on the left and start building with the Smartsheet API!
public isolated client class Client {
    final http:Client clientEp;

    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector`
    # + serviceUrl - URL of the target service
    # + return - An error if connector initialization failed
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.smartsheet.com/2.0") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List Contacts
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Contact objects
    resource isolated function get contacts(ListContactsHeaders headers = {}, *ListContactsQueries queries) returns ContactListResponse|error {
        string resourcePath = string `/contacts`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Contact
    #
    # + contactId - contactId of the contact being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Contact object
    resource isolated function get contacts/[decimal contactId](GetContactHeaders headers = {}, *GetContactQueries queries) returns Contact|error {
        string resourcePath = string `/contacts/${getEncodedUri(contactId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List events
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get events(ListEventsHeaders headers = {}, *ListEventsQueries queries) returns EventStreamResponse|error {
        string resourcePath = string `/events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Favorites
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Favorite objects
    resource isolated function get favorites(GetFavoritesHeaders headers = {}, *GetFavoritesQueries queries) returns ContactResponse|error {
        string resourcePath = string `/favorites`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Favorites
    #
    # + headers - Headers to be sent with the request
    # + payload - A list of favorites to be added
    # + return - Result object containing either a single Favorite object or an array of Favorite objects
    resource isolated function post favorites(FavoritesBody payload, AddFavoriteHeaders headers = {}) returns FavoriteResultResponse|error {
        string resourcePath = string `/favorites`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Multiple Favorites
    #
    # + favoriteType - The favorite type
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object
    resource isolated function delete favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType](DeleteFavoritesByTypeHeaders headers = {}, *DeleteFavoritesByTypeQueries queries) returns GenericResult|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Is Favorite
    #
    # + favoriteType - The favorite type
    # + favoriteId - Favorite Id, e.g., sheet Id, report Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object
    resource isolated function get favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType]/[decimal favoriteId](IsFavoriteHeaders headers = {}, *IsFavoriteQueries queries) returns Favorite|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}/${getEncodedUri(favoriteId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Favorite
    #
    # + favoriteType - The favorite type
    # + favoriteId - Favorite Id, e.g., sheet Id, report Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType]/[decimal favoriteId](DeleteFavoritesByTypeAndIdHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}/${getEncodedUri(favoriteId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List filtered events
    #
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function post filteredEvents(FilteredEventsRequest payload, ListFilteredEventsHeaders headers = {}) returns EventFilterResponse|error {
        string resourcePath = string `/filteredEvents`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - A single Folder object
    resource isolated function get folders/[decimal folderId](GetFolderHeaders headers = {}, *GetFolderQueries queries) returns Folder|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + return - Result object containing the modified Folder object
    resource isolated function put folders/[decimal folderId](Folder payload, UpdateFolderHeaders headers = {}) returns CrossSheetReferenceResponse|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete folders/[decimal folderId](DeleteFolderHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - New folder name
    # + return - Result object containing a Folder object for the new folder destination
    resource isolated function post folders/[decimal folderId]/copy(FolderIdCopyBody payload, CopyFolderHeaders headers = {}, *CopyFolderQueries queries) returns ContainerDestinationForCopy|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Folders
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Folder objects
    resource isolated function get folders/[decimal folderId]/folders(ListFoldersHeaders headers = {}, *ListFoldersQueries queries) returns SearchResponse|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Folder to create
    # + return - Result object containing a Folder object for newly created folder
    resource isolated function post folders/[decimal folderId]/folders(FolderIdFoldersBody payload, CreateFolderFolderHeaders headers = {}, *CreateFolderFolderQueries queries) returns SharedSecretResponse|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + payload - New folder destination
    # + return - Result object containing a Folder object for the new folder destination
    resource isolated function post folders/[decimal folderId]/move(FolderIdMoveBody payload, MoveFolderHeaders headers = {}) returns ContainerDestinationForMove|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create Sheet in Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Sheet to create
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request
    resource isolated function post folders/[decimal folderId]/sheets(FolderIdSheetsBody payload, CreateSheetInFolderHeaders headers = {}, *CreateSheetInFolderQueries queries) returns WebhookResponse|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet into Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Binary content for the CSV / XLSX file
    # + return - Result object containing a Sheet object for imported sheet
    resource isolated function post folders/[decimal folderId]/sheets/'import(ImportSheetIntoFolderHeaders headers, byte[] payload, *ImportSheetIntoFolderQueries queries) returns WebhookListResponse|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Contents
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - A single Home object
    #
    # # Deprecated
    @deprecated
    resource isolated function get folders/personal(ListHomeContentsHeaders headers = {}, *ListHomeContentsQueries queries) returns Home|error {
        string resourcePath = string `/folders/personal`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Org Groups
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of [Group objects](/api/smartsheet/openapi/groups/group)
    resource isolated function get groups(ListGroupsHeaders headers = {}, *ListGroupsQueries queries) returns GroupResponse|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Group
    #
    # + headers - Headers to be sent with the request
    # + payload - [Group object](/api/smartsheet/openapi/groups/group), limited to the following attributes:
    # + return - Result object, containing a [Group object](/api/smartsheet/openapi/groups/group) for the newly created group
    resource isolated function post groups(GroupCreate1 payload, AddGroupHeaders headers = {}) returns GroupCreateResponse|error {
        string resourcePath = string `/groups`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request
    # + return - [Group](/api/smartsheet/openapi/groups/group) object that includes the list of [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) objects
    resource isolated function get groups/[decimal groupId](GetGroupHeaders headers = {}) returns GroupMembersResponse|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request
    # + payload - Group object, limited to the following attributes:
    # + return - Result object containing the [Group object](/api/smartsheet/openapi/groups/group) for the updated group
    resource isolated function put groups/[decimal groupId](GroupUpdate1 payload, UpdateGroupHeaders headers = {}) returns GroupCreateResponse|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request
    # + return - **_This operation is asynchronous,_** _meaning group members may retain their sharing access for a brief period of time after the call returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._
    resource isolated function delete groups/[decimal groupId](DeleteGroupHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Add Group Members
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request
    # + return - Returns a Result object containing the members added to the group -- either a single [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) or array of [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) objects, corresponding to what was specified in the request. **_This operation is asynchronous,_** _meaning the users may not yet have sharing access to sheets for a period of time after this operation returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._
    resource isolated function post groups/[decimal groupId]/members(GroupIdMembersBody payload, AddGroupMembersHeaders headers = {}) returns GroupMembersListResponse|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Group Members
    #
    # + groupId - Group Id
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - **_This operation is asynchronous,_** _meaning the users may not yet have sharing access to sheets for a period of time after this operation returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._
    resource isolated function delete groups/[decimal groupId]/members/[decimal userId](DeleteGroupMembersHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Folders in Home
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Folder objects
    resource isolated function get home/folders(HomeListFoldersHeaders headers = {}, *HomeListFoldersQueries queries) returns SearchResponse|error {
        string resourcePath = string `/home/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Folder
    #
    # + headers - Headers to be sent with the request
    # + payload - Folder to create
    # + return - Result object containing a Folder object for newly created folder
    #
    # # Deprecated
    @deprecated
    resource isolated function post home/folders(HomeFoldersBody payload, CreateHomeFolderHeaders headers = {}) returns SharedSecretResponse|error {
        string resourcePath = string `/home/folders`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Image URLs
    #
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function post imageurls(InlineBodyItemsApplicationjsonimageurls[] payload, ListImageUrlsHeaders headers = {}) returns ImageUrlMapResponse|error {
        string resourcePath = string `/imageurls`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Reports
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Object containing an array of all accessible reports, referenced by their ID, name, access level, and summary report flag values
    resource isolated function get reports(GetReportsHeaders headers = {}, *GetReportsQueries queries) returns TemplateListResponse|error {
        string resourcePath = string `/reports`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Report
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The Report that was loaded
    resource isolated function get reports/[decimal reportId](GetReportHeaders headers = {}, *GetReportQueries queries) returns Report|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Send report via email
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + return - Result Object
    resource isolated function post reports/[decimal reportId]/emails(SheetEmail payload, SendReportViaEmailHeaders headers = {}) returns Result|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Gets a Report's publish settings
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + return - The Report's publish settings
    resource isolated function get reports/[decimal reportId]/publish(GetReportPublishHeaders headers = {}) returns ReportPublish|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set a Report's publish status
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + return - ReportPublish object
    resource isolated function put reports/[decimal reportId]/publish(ReportPublish payload, SetReportPublishHeaders headers = {}) returns ReportPublishResponse|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Report Shares
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (include=workspaceShares) also be returned
    resource isolated function get reports/[decimal reportId]/shares(ListReportSharesHeaders headers = {}, *ListReportSharesQueries queries) returns PublicTemplateListResponse|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Report
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM
    resource isolated function post reports/[decimal reportId]/shares(ReportIdSharesBody payload, ShareReportHeaders headers = {}, *ShareReportQueries queries) returns TokenResponse|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Share object
    resource isolated function get reports/[decimal reportId]/shares/[string shareId](ShareReportGetHeaders headers = {}, *ShareReportGetQueries queries) returns Share|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing the modified Share object
    resource isolated function put reports/[decimal reportId]/shares/[string shareId](SharesshareIdBody payload, UpdateReportShareHeaders headers = {}, *UpdateReportShareQueries queries) returns UserResponse|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object
    resource isolated function delete reports/[decimal reportId]/shares/[string shareId](DeleteReportShareHeaders headers = {}, *DeleteReportShareQueries queries) returns Result|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Search Everything
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SearchResult object that contains an array of Search objects (maximum 100)
    resource isolated function get search(ListSearchHeaders headers = {}, *ListSearchQueries queries) returns UserCreateResponse|error {
        string resourcePath = string `/search`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}, "scopes": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SearchResult object containing an array of SearchResultItem objects in a sheet (maximum 100)
    resource isolated function get search/sheets/[decimal sheetId](ListSearchSheetHeaders headers = {}, *ListSearchSheetQueries queries) returns AlternateEmailResponse|error {
        string resourcePath = string `/search/sheets/${getEncodedUri(sheetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Gets application constants.
    #
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function get serverinfo(map<string|string[]> headers = {}) returns ServerInfo|error {
        string resourcePath = string `/serverinfo`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Sheets
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets(ListSheetsHeaders headers = {}, *ListSheetsQueries queries) returns AlternateEmailListResponse|error {
        string resourcePath = string `/sheets`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Sheet in "Sheets" Folder
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Sheet to create
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request
    #
    # # Deprecated
    @deprecated
    resource isolated function post sheets(SheetsBody payload, CreateSheetInSheetsFolderHeaders headers = {}, *CreateSheetInSheetsFolderQueries queries) returns WebhookResponse|error {
        string resourcePath = string `/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet from CSV / XLSX
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Binary content for the CSV / XLSX file
    # + return - Result object containing a Sheet object for imported sheet
    #
    # # Deprecated
    @deprecated
    resource isolated function post sheets/'import(ImportSheetIntoSheetsFolderHeaders headers, byte[] payload, *ImportSheetIntoSheetsFolderQueries queries) returns WebhookListResponse|error {
        string resourcePath = string `/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The Sheet that was loaded
    resource isolated function get sheets/[decimal sheetId](GetSheetHeaders headers = {}, *GetSheetQueries queries) returns FavoriteResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        map<Encoding> queryParamEncoding = {"rowsModifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - [Sheet object](/api/smartsheet/openapi/sheets/sheet) limited to the following attributes:
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing a [Sheet object](/api/smartsheet/openapi/sheets/sheet) for the updated sheet
    resource isolated function put sheets/[decimal sheetId](UpdateSheet payload, UpdateSheetHeaders headers = {}, *UpdateSheetQueries queries) returns AttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId](DeleteSheetHeaders headers = {}) returns SuccessResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/attachments(AttachmentsListOnSheetHeaders headers = {}, *AttachmentsListOnSheetQueries queries) returns AttachmentVersionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File or URL to Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/attachments(byte[] payload, AttachmentsAttachToSheetHeaders headers = {}) returns AttachmentVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Attachment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets/[decimal sheetId]/attachments/[string attachmentId](AttachmentsGetHeaders headers = {}) returns AttachmentResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Attachment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/attachments/[string attachmentId](AttachmentsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(AttachmentsVersionListHeaders headers = {}, *AttachmentsVersionListQueries queries) returns AttachmentVersionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach New version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(byte[] payload, AttachmentsVersionUploadHeaders headers = {}) returns AttachmentVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete All Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(AttachmentsVersionsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List All Automation Rules
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The list of AutomationRule objects
    resource isolated function get sheets/[decimal sheetId]/automationrules(AutomationrulesListHeaders headers = {}, *AutomationrulesListQueries queries) returns AutomationRuleListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request
    # + return - AutomationRule object
    resource isolated function get sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationruleGetHeaders headers = {}) returns AutomationRuleResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request
    # + return - Result object containing the updated AutomationRule object
    resource isolated function put sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationRule payload, AutomationruleUpdateHeaders headers = {}) returns AutomationRuleUpdateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request
    # + return - Result object
    resource isolated function delete sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationruleDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Columns
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns [IndexResult object]() containing an array of [Column objects]()
    resource isolated function get sheets/[decimal sheetId]/columns(ColumnsListOnSheetHeaders headers = {}, *ColumnsListOnSheetQueries queries) returns ColumnListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Columns
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - A [Column object]() that contains the following attributes
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the newly created columns -- either a single [Column object](/api/smartsheet/openapi/columns/column) or an array of Column objects, corresponding to what was specified in the request
    resource isolated function post sheets/[decimal sheetId]/columns(ColumnObjectAttributes payload, ColumnsAddToSheetHeaders headers = {}) returns ColumnCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets/[decimal sheetId]/columns/[decimal columnId](ColumnGetHeaders headers = {}, *ColumnGetQueries queries) returns ColumnResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - A [Column object]() that contains the following attributes:
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the [Column object](/api/smartsheet/openapi/columns/column) that was modified
    resource isolated function put sheets/[decimal sheetId]/columns/[decimal columnId](ColumnObjectAttributes payload, ColumnUpdateColumnHeaders headers = {}) returns ColumnUpdateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/columns/[decimal columnId](ColumnDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets/[decimal sheetId]/comments/[string commentId](CommentGetHeaders headers = {}) returns CommentResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Edit a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function put sheets/[decimal sheetId]/comments/[string commentId](CommentCreationRequest payload, CommentEditHeaders headers = {}) returns CommentCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/comments/[string commentId](CommentDeleteHeaders headers = {}) returns CommentUpdateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Attach File or URL to Comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/comments/[string commentId]/attachments(byte[] payload, AttachmentsAttachToCommentHeaders headers = {}) returns AttachmentVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Copy Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Destination where to create a copy of the specified sheet
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/copy(ContainerDestinationForCopy payload, CopySheetHeaders headers = {}, *CopySheetQueries queries) returns CrossSheetReferenceListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Cross-sheet References
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of CrossSheetReference objects
    resource isolated function get sheets/[decimal sheetId]/crosssheetreferences(ListCrosssheetReferencesHeaders headers = {}, *ListCrosssheetReferencesQueries queries) returns CrossSheetReferenceCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Cross-sheet References
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - CrossSheetReference object to create
    # + return - Result object containing a CrossSheetReference object, corresponding to what was specified in the request
    resource isolated function post sheets/[decimal sheetId]/crosssheetreferences(SheetIdCrosssheetreferencesBody payload, AddCrosssheetReferenceHeaders headers = {}) returns DiscussionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Cross-sheet Reference
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + crossSheetReferenceId - Cross-sheet Reference Id
    # + headers - Headers to be sent with the request
    # + return - CrossSheetReference object
    resource isolated function get sheets/[decimal sheetId]/crosssheetreferences/[decimal crossSheetReferenceId](GetCrosssheetReferenceHeaders headers = {}) returns CrossSheetReference|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences/${getEncodedUri(crossSheetReferenceId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Discussions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/discussions(DiscussionsListHeaders headers = {}, *DiscussionsListQueries queries) returns DiscussionCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/discussions(DiscussionCreationRequest payload, DiscussionsCreateHeaders headers = {}) returns DiscussionAttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets/[decimal sheetId]/discussions/[string discussionId](DiscussionGetHeaders headers = {}) returns DiscussionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete a Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/discussions/[string discussionId](DiscussionDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Discussion Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/discussions/[string discussionId]/attachments(DiscussionListAttachmentsHeaders headers = {}, *DiscussionListAttachmentsQueries queries) returns AttachmentVersionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/discussions/[string discussionId]/comments(CommentCreationRequest payload, CommentsCreateHeaders headers = {}) returns ProofListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}/comments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Send Sheet via Email
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - [SheetEmail object](/api/smartsheet/openapi/sendviaemail/sheetemail)
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/emails(SheetEmail payload, SheetSendHeaders headers = {}) returns ProofCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - Destination to move the specified sheet
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/move(ContainerDestinationForMove payload, MoveSheetHeaders headers = {}) returns CrossSheetReferenceListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proofs
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/proofs(ProofsGetAllProofsHeaders headers = {}, *ProofsGetAllProofsQueries queries) returns ProofDetailListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId](ProofsGetHeaders headers = {}, *ProofsGetQueries queries) returns ProofResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Proof Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function put sheets/[decimal sheetId]/proofs/[string proofId](UpdateProofStatusRequest payload, ProofsUpdateHeaders headers = {}) returns ProofResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId](ProofsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Proof Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/attachments(ProofsListAttachmentsHeaders headers = {}, *ProofsListAttachmentsQueries queries) returns ProofAttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File to Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/attachments(byte[] payload, ProofsAttachToProofHeaders headers = {}) returns AttachmentVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proof Discussions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/discussions(ProofsListDiscussionsHeaders headers = {}, *ProofsListDiscussionsQueries queries) returns ProofDiscussionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/discussions(DiscussionCreationRequest payload, ProofsCreateDiscussionHeaders headers = {}) returns DiscussionAttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proof Request Actions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/requestactions(ProofsListRequestActionsHeaders headers = {}, *ProofsListRequestActionsQueries queries) returns ProofRequestActionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requestactions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/requests(ProofRequestBody payload, ProofsCreateProofRequestsHeaders headers = {}) returns ProofRequestCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Proof Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId]/requests(ProofsDeleteProofRequestsHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Proof Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/versions(ProofsGetVersionsHeaders headers = {}, *ProofsGetVersionsQueries queries) returns ProofVersionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/versions(byte[] payload, ProofsCreateVersionHeaders headers = {}) returns ProofVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Proof Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId]/versions(ProofsDeleteVersionHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get Sheet Publish Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/publish(GetSheetPublishHeaders headers = {}) returns SheetPublish|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Sheet Publish Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - SheetPublish object
    # + return - OK
    resource isolated function put sheets/[decimal sheetId]/publish(SheetPublishRequest payload, SetSheetPublishHeaders headers = {}) returns SheetPublishResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Update Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - [Row object](/api/smartsheet/openapi/rows/row) or an array of Row objects, with the following attributes:
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing an array of the updated rows
    resource isolated function put sheets/[decimal sheetId]/rows(SheetIdRowsBody payload, UpdateRowsHeaders headers = {}, *UpdateRowsQueries queries) returns RowCopyResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Add Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - [Row object](/api/smartsheet/openapi/rows/row) or an array of Row objects, with the following attributes:
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the newly created rows -- either a single [Row object](/api/smartsheet/openapi/rows/row) or array of Row objects, corresponding to what was specified in the request, as well as the new version of the sheet
    resource isolated function post sheets/[decimal sheetId]/rows(SheetIdRowsBody1 payload, RowsAddToSheetHeaders headers = {}, *RowsAddToSheetQueries queries) returns RowMoveResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing row Ids corresponding to all rows that were successfully deleted (including any child rows of rows specified in the URL)
    resource isolated function delete sheets/[decimal sheetId]/rows(DeleteRowsHeaders headers = {}, *DeleteRowsQueries queries) returns RowListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Send Rows via Email
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - The columns included for each row in the email are populated according to the following rules:
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/rows/emails(MultiRowEmail payload, RowsSendHeaders headers = {}) returns ProofCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Copy Rows to Another Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - CopyOrMoveRowResult object
    resource isolated function post sheets/[decimal sheetId]/rows/copy(CopyOrMoveRowDirective payload, CopyRowsHeaders headers = {}, *CopyRowsQueries queries) returns CopyOrMoveRowResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Rows to Another Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - CopyOrMoveRowResult object
    resource isolated function post sheets/[decimal sheetId]/rows/move(CopyOrMoveRowDirective payload, MoveRowsHeaders headers = {}, *MoveRowsQueries queries) returns CopyOrMoveRowResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/move`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns [Row object]() populated according to the specified parameters
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId](RowGetHeaders headers = {}, *RowGetQueries queries) returns RowResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Row Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/attachments(AttachmentsListOnRowHeaders headers = {}, *AttachmentsListOnRowQueries queries) returns AttachmentVersionListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File or URL to Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/attachments(byte[] payload, RowAttachmentsAttachFileHeaders headers = {}) returns AttachmentVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Add Image to Cell
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/columns/[decimal columnId]/cellimages(byte[] payload, AddImageToCellHeaders headers = {}, *AddImageToCellQueries queries) returns RowCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/columns/${getEncodedUri(columnId)}/cellimages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Cell History
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/columns/[decimal columnId]/history(CellHistoryGetHeaders headers = {}, *CellHistoryGetQueries queries) returns RowAttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/columns/${getEncodedUri(columnId)}/history`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Discussions with a Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/discussions(RowDiscussionsListHeaders headers = {}, *RowDiscussionsListQueries queries) returns DiscussionCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Discussion on a Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/discussions(DiscussionCreationRequest payload, RowDiscussionsCreateHeaders headers = {}) returns DiscussionAttachmentListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/proofs(byte[] payload, ProofsCreateHeaders headers = {}) returns ProofVersionResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/proofs`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Sent Update Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The list of SentUpdateRequest objects
    resource isolated function get sheets/[decimal sheetId]/sentupdaterequests(SentupdaterequestsListHeaders headers = {}, *SentupdaterequestsListQueries queries) returns SentUpdateRequestListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Sent Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + sentUpdateRequestId - ID of the sent update request
    # + headers - Headers to be sent with the request
    # + return - SentUpdateRequest object
    resource isolated function get sheets/[decimal sheetId]/sentupdaterequests/[string sentUpdateRequestId](SentupdaterequestGetHeaders headers = {}) returns SentUpdateRequest|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests/${getEncodedUri(sentUpdateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Sent Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + sentUpdateRequestId - ID of the sent update request
    # + headers - Headers to be sent with the request
    # + return - Result object
    resource isolated function delete sheets/[decimal sheetId]/sentupdaterequests/[string sentUpdateRequestId](SentupdaterequestDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests/${getEncodedUri(sentUpdateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get Sheet Summary
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/summary(ListSummaryFieldsHeaders headers = {}, *ListSummaryFieldsQueries queries) returns SheetSummary|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/summary/fields(ListSummaryFieldsPaginatedHeaders headers = {}, *ListSummaryFieldsPaginatedQueries queries) returns SummaryFieldListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Array of SummaryField objects
    # + return - OK
    resource isolated function put sheets/[decimal sheetId]/summary/fields(SummaryFieldUpdateRequest[] payload, UpdateSummaryFieldsHeaders headers = {}, *UpdateSummaryFieldsQueries queries) returns SummaryFieldCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Add Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Array of SummaryField objects
    # + return - OK
    resource isolated function post sheets/[decimal sheetId]/summary/fields(SummaryFieldCreateRequest[] payload, AddSummaryFieldsHeaders headers = {}, *AddSummaryFieldsQueries queries) returns SummaryFieldBulkCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - OK
    resource isolated function delete sheets/[decimal sheetId]/summary/fields(DeleteSummaryFieldsHeaders headers = {}, *DeleteSummaryFieldsQueries queries) returns SummaryFieldDeleteResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Add Image to Sheet Summary
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + fieldId - Summary Field Id of the sheet summary field being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function post sheets/[decimal sheetId]/summary/fields/[decimal fieldId]/images(byte[] payload, AddImageSummaryFieldHeaders headers = {}, *AddImageSummaryFieldQueries queries) returns SummaryResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields/${getEncodedUri(fieldId)}/images`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Update Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The list of UpdateRequest objects
    resource isolated function get sheets/[decimal sheetId]/updaterequests(UpdaterequestsListHeaders headers = {}, *UpdaterequestsListQueries queries) returns UpdateRequestListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - Result object containing the newly created UpdateRequest object
    resource isolated function post sheets/[decimal sheetId]/updaterequests(UpdateRequest payload, UpdaterequestsCreateHeaders headers = {}) returns UpdateRequestCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request
    # + return - UpdateRequest object
    resource isolated function get sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsGetHeaders headers = {}) returns UpdateRequest|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request
    # + return - Result object containing the modified UpdateRequest object
    resource isolated function put sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsUpdateHeaders headers = {}) returns UpdateRequestCreateResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request
    # + return - Result object
    resource isolated function delete sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Sheet Shares
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (include=workspaceShares) also be returned
    resource isolated function get sheets/[decimal sheetId]/shares(ListSheetSharesHeaders headers = {}, *ListSheetSharesQueries queries) returns PublicTemplateListResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM
    resource isolated function post sheets/[decimal sheetId]/shares(SheetIdSharesBody payload, ShareSheetHeaders headers = {}, *ShareSheetQueries queries) returns TokenResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet Share.
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Share object
    resource isolated function get sheets/[decimal sheetId]/shares/[string shareId](ShareSheetGetHeaders headers = {}, *ShareSheetGetQueries queries) returns Share|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Sheet Share.
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object containing the modified Share object
    resource isolated function put sheets/[decimal sheetId]/shares/[string shareId](SharesshareIdBody payload, UpdateSheetShareHeaders headers = {}, *UpdateSheetShareQueries queries) returns UserResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Sheet Share
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object
    resource isolated function delete sheets/[decimal sheetId]/shares/[string shareId](DeleteSheetShareHeaders headers = {}, *DeleteSheetShareQueries queries) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Sort Rows in Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - [SortSpecifier](/api/smartsheet/openapi/schemas/sortspecifier) with the following attribute:
    # + return - Returns [Sheet object](/api/smartsheet/openapi/sheets/sheet), populated according to the specified parameters
    resource isolated function post sheets/[decimal sheetId]/sort(SortSpecifier payload, RowsSortHeaders headers = {}, *RowsSortQueries queries) returns SheetResponse|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sort`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function get sheets/[decimal sheetId]/version(GetSheetVersionHeaders headers = {}) returns SheetVersion|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/version`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Dashboards
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Dashboard objects with a subset of attributes
    resource isolated function get sights(ListSightsHeaders headers = {}, *ListSightsQueries queries) returns DashboardListResponse|error {
        string resourcePath = string `/sights`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Dashboard object
    resource isolated function get sights/[string sightId](GetSightHeaders headers = {}, *GetSightQueries queries) returns Sight|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing the updated Dashboard object
    resource isolated function put sights/[string sightId](SightName payload, UpdateSightHeaders headers = {}, *UpdateSightQueries queries) returns ShareResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + return - Generic response result
    resource isolated function delete sights/[string sightId](DeleteSightHeaders headers = {}) returns ProofCreateResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + return - Result object containing a dashboard with a subset of attributes for the newly created dashboard
    resource isolated function post sights/[string sightId]/copy(ContainerDestinationForCopy payload, CopySightHeaders headers = {}) returns ShareCreateResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/copy`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + return - Result object containing a Dashboard object with a subset of attributes for the moved dashboard
    resource isolated function post sights/[string sightId]/move(ContainerDestinationForMove payload, MoveSightHeaders headers = {}) returns ShareCreateResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Dashboard Publish Status
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + return - SightPublish object
    resource isolated function get sights/[string sightId]/publish(GetSightPublishStatusHeaders headers = {}) returns SightPublish|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Dashboard Publish Status
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + return - SightPublish object
    resource isolated function put sights/[string sightId]/publish(SightPublish payload, SetSightPublishStatusHeaders headers = {}) returns ShareUpdateResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Dashboard Shares
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (scope=WORKSPACE) also be returned
    resource isolated function get sights/[string sightId]/shares(ListSightSharesHeaders headers = {}, *ListSightSharesQueries queries) returns PublicTemplateListResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM
    resource isolated function post sights/[string sightId]/shares(Share payload, ShareSightHeaders headers = {}, *ShareSightQueries queries) returns TokenResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Share object
    resource isolated function get sights/[string sightId]/shares/[string shareId](ShareSightGetHeaders headers = {}, *ShareSightGetQueries queries) returns Share|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object containing the modified Share object
    resource isolated function put sights/[string sightId]/shares/[string shareId](SharesshareIdBody payload, UpdateSightShareHeaders headers = {}, *UpdateSightShareQueries queries) returns UserResponse|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete sights/[string sightId]/shares/[string shareId](DeleteSightShareHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List User-Created Templates
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function get templates(TemplatesListHeaders headers = {}, *TemplatesListQueries queries) returns WorkspaceListResponse|error {
        string resourcePath = string `/templates`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Public Templates
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function get templates/'public(TemplatesListPublicHeaders headers = {}, *TemplatesListPublicQueries queries) returns WorkspaceListResponse|error {
        string resourcePath = string `/templates/public`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Gets or Refreshes an Access Token
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - An access token
    resource isolated function post token(TokensGetOrRefreshHeaders headers = {}, *TokensGetOrRefreshQueries queries) returns Token|error {
        string resourcePath = string `/token`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Revoke Access Token
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - SUCCESS
    resource isolated function delete token(TokensDeleteHeaders headers = {}, *TokensDeleteQueries queries) returns Result|error {
        string resourcePath = string `/token`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Users
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of [User objects](/api/smartsheet/openapi/users/user)
    resource isolated function get users(ListUsersHeaders headers = {}, *ListUsersQueries queries) returns UserListResponse|error {
        string resourcePath = string `/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add User
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - The User to be created
    # + return - Result object containing the newly created [User object](/api/smartsheet/openapi/users/user)
    resource isolated function post users(User payload, AddUserHeaders headers = {}, *AddUserQueries queries) returns UserProfileResponse|error {
        string resourcePath = string `/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Current User
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResultUnknownPages object containing a UserProfile object
    resource isolated function get users/me(GetCurrentUserHeaders headers = {}, *GetCurrentUserQueries queries) returns UserImgProfileResponse|error {
        string resourcePath = string `/users/me`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Org Sheets
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResultUnknownPages object containing an array of Sheet objects, limited to the following attributes: * id * name * owner: empty string * ownerId: (static "0")
    resource isolated function get users/sheets(ListOrgSheetsHeaders headers = {}, *ListOrgSheetsQueries queries) returns HomeContentsResponse|error {
        string resourcePath = string `/users/sheets`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - Returns UserProfile object
    resource isolated function get users/[decimal userId](GetUserHeaders headers = {}) returns UserProfile|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + payload - User object containing at least one of the following attributes:
    # + return - Result object containing the [User object](/api/smartsheet/openapi/users/user) for the updated user
    resource isolated function put users/[decimal userId](UserUpdate payload, UpdateUserHeaders headers = {}) returns HomeFolderCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Remove User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Result object
    resource isolated function delete users/[decimal userId](RemoveUserHeaders headers = {}, *RemoveUserQueries queries) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Alternate Emails
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - IndexResult object containing an array of [AlternateEmail objects](/api/smartsheet/openapi/alternateemailaddress/alternateemail)
    resource isolated function get users/[decimal userId]/alternateemails(ListAlternateEmailsHeaders headers = {}) returns FolderListResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Alternate Emails
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - Result object containing an array of the newly created [AlternateEmail objects](/api/smartsheet/openapi/alternateemailaddress/alternateemail)
    resource isolated function post users/[decimal userId]/alternateemails(UserIdAlternateemailsBody payload, AddAlternateEmailHeaders headers = {}) returns FolderCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Alternate Email
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request
    # + return - Returns [AlternateEmail object](/api/smartsheet/openapi/alternateemailaddress/alternateemail)
    resource isolated function get users/[decimal userId]/alternateemails/[decimal alternateEmailId](GetAlternateEmailHeaders headers = {}) returns AlternateEmail|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Alternate Email
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete users/[decimal userId]/alternateemails/[decimal alternateEmailId](DeleteAlternateEmailHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Make Alternate Email Primary
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function post users/[decimal userId]/alternateemails/[decimal alternateEmailId]/makeprimary(PromoteAlternateEmailHeaders headers = {}) returns FolderCopyResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}/makeprimary`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Deactivate User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function post users/[decimal userId]/deactivate(DeactivateUserHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/deactivate`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update User Profile Image
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function post users/[decimal userId]/profileimage(byte[] payload, UpdateUserProfileImageHeaders headers = {}) returns HomeFolderCreateResponse|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/profileimage`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Reactivate User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function post users/[decimal userId]/reactivate(ReactivateUserHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/reactivate`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Webhooks
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - The List of Webhooks
    resource isolated function get webhooks(ListWebhooksHeaders headers = {}, *ListWebhooksQueries queries) returns WorkspaceFolderListResponse|error {
        string resourcePath = string `/webhooks`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Webhook
    #
    # + headers - Headers to be sent with the request
    # + return - Result object, containing a Webhook object for the newly created webhook
    resource isolated function post webhooks(WebhooksBody payload, CreateWebhookHeaders headers = {}) returns WorkspaceFolderCreateResponse|error {
        string resourcePath = string `/webhooks`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request
    # + return - Webhook object
    resource isolated function get webhooks/[string webhookId](GetWebhookHeaders headers = {}) returns Webhook|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request
    # + return - Result object containing the Webhook object for the updated webhook
    resource isolated function put webhooks/[string webhookId](UpdateWebhookRequest payload, UpdateWebhookHeaders headers = {}) returns WorkspaceFolderCreateResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request
    # + return - Result object
    resource isolated function delete webhooks/[string webhookId](DeleteWebhookHeaders headers = {}) returns WorkspaceShareDeleteResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reset Shared Secret
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request
    # + return - OK
    resource isolated function post webhooks/[string webhookId]/resetSharedSecret(ResetSharedSecretHeaders headers = {}) returns WorkspaceShareCreateResponse|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/resetSharedSecret`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspaces
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Workspace objects
    resource isolated function get workspaces(ListWorkspacesHeaders headers = {}, *ListWorkspacesQueries queries) returns WorkspaceShareListResponse|error {
        string resourcePath = string `/workspaces`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Workspace
    #
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Workspace to create
    # + return - Result object containing a Workspace object for newly created workspace
    resource isolated function post workspaces(WorkspacesBody payload, CreateWorkspaceHeaders headers = {}, *CreateWorkspaceQueries queries) returns WorkspaceResponse|error {
        string resourcePath = string `/workspaces`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - A single Workspace object
    resource isolated function get workspaces/[string workspaceId](GetWorkspaceHeaders headers = {}, *GetWorkspaceQueries queries) returns Workspace|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing the modified Workspace object
    resource isolated function put workspaces/[string workspaceId](WorkspacesworkspaceIdBody payload, UpdateWorkspaceHeaders headers = {}, *UpdateWorkspaceQueries queries) returns WorkspaceCreateResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete workspaces/[string workspaceId](DeleteWorkspaceHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - New workspace name
    # + return - Result object containing a Workspace object for the new workspace destination
    resource isolated function post workspaces/[string workspaceId]/copy(WorkspaceIdCopyBody payload, CopyWorkspaceHeaders headers = {}, *CopyWorkspaceQueries queries) returns ContainerDestinationForCopy|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspace Folders
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - An array of Folder references
    resource isolated function get workspaces/[string workspaceId]/folders(GetWorkspaceFoldersHeaders headers = {}, *GetWorkspaceFoldersQueries queries) returns FolderContentsResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Folder
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + payload - Folder to create
    # + return - Result object containing a Folder object for newly created folder
    resource isolated function post workspaces/[string workspaceId]/folders(FolderNameOnly payload, CreateWorkspaceFolderHeaders headers = {}) returns CellHistoryResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/folders`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspace Shares
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - IndexResult object containing an array of Share objects
    resource isolated function get workspaces/[string workspaceId]/shares(ListWorkspaceSharesHeaders headers = {}, *ListWorkspaceSharesQueries queries) returns PublicTemplateListResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - This operation supports both single-object and bulk semantics. For more information, see Optional Bulk Operations
    resource isolated function post workspaces/[string workspaceId]/shares(WorkspaceIdSharesBody payload, ShareWorkspaceHeaders headers = {}, *ShareWorkspaceQueries queries) returns TokenResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Returns Share object
    resource isolated function get workspaces/[string workspaceId]/shares/[string shareId](ShareWorkspaceGetHeaders headers = {}, *ShareWorkspaceGetQueries queries) returns Share|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + return - Result object containing the modified Share object
    resource isolated function put workspaces/[string workspaceId]/shares/[string shareId](SharesshareIdBody payload, UpdateWorkspaceShareHeaders headers = {}, *UpdateWorkspaceShareQueries queries) returns UserResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request
    # + return - Returns Result object
    resource isolated function delete workspaces/[string workspaceId]/shares/[string shareId](DeleteWorkspaceShareHeaders headers = {}) returns Result|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Create Sheet in Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Sheet to create
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request
    resource isolated function post workspaces/[string workspaceId]/sheets(WorkspaceIdSheetsBody payload, CreateSheetInWorkspaceHeaders headers = {}, *CreateSheetInWorkspaceQueries queries) returns WebhookResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet into Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request
    # + queries - Queries to be sent with the request
    # + payload - Binary content for the CSV / XLSX file
    # + return - Result object containing a Sheet object for imported sheet
    resource isolated function post workspaces/[string workspaceId]/sheets/'import(ImportSheetIntoWorkspaceHeaders headers, byte[] payload, *ImportSheetIntoWorkspaceQueries queries) returns WebhookListResponse|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }
}
