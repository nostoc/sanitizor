// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/data.jsondata;
import ballerina/http;

# Welcome to the OpenAPI reference documentation for the Smartsheet API!
# 
# > **IMPORTANT:**
# > * The Smartsheet API is restricted to users on Business and Enterprise plans
# > * The <a href="https://www.smartsheet.com/legal/developer-program-agreement" target="_blank" rel="noopener noreferrer">Developer Agreement</a> governs the use of the Smartsheet API and Smartsheet software development kits (SDKs)
# 
# **QUICKLINKS**
# 
# - **Base URL:**
# 
#     ```
#     https://api.smartsheet.com/2.0/
#     ```
# 
# - **Getting started:** <a href="https://help.smartsheet.com/articles/2482389-generate-API-key" target="_blank" rel="noopener noreferrer">Generate an API access token</a> and [make a request](/api/smartsheet/guides/getting-started).
# 
# - **Changelog:** See the latest [API updates](/api/smartsheet/changelog).
# 
# - **Schemas:** View the [object schemas](/api/smartsheet/openapi/schemas) not explicitly listed in the resource sections.
# 
# - **Error codes:** Look up common API [error codes](/api/smartsheet/error-codes).
# 
# - **Guides:** Learn various ways of using the API with the help of our [Guides](/api/smartsheet/introduction).
# 
# Browse the Smartsheet API operations by resource on the left and start building with the Smartsheet API!
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.smartsheet.com/2.0") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List Contacts
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Contact objects 
    resource isolated function get contacts(ListContactsHeaders headers = {}, *ListContactsQueries queries) returns InlineResponse200|error {
        string resourcePath = string `/contacts`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Contact
    #
    # + contactId - contactId of the contact being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Contact object 
    resource isolated function get contacts/[decimal contactId](GetContactHeaders headers = {}, *GetContactQueries queries) returns Contact|error {
        string resourcePath = string `/contacts/${getEncodedUri(contactId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List events
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get events(ListEventsHeaders headers = {}, *ListEventsQueries queries) returns InlineResponse2001|error {
        string resourcePath = string `/events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Favorites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Favorite objects 
    resource isolated function get favorites(GetFavoritesHeaders headers = {}, *GetFavoritesQueries queries) returns InlineResponse2002|error {
        string resourcePath = string `/favorites`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Favorites
    #
    # + headers - Headers to be sent with the request 
    # + payload - A list of favorites to be added 
    # + return - Result object containing either a single Favorite object or an array of Favorite objects 
    resource isolated function post favorites(FavoritesBody payload, AddFavoriteHeaders headers = {}) returns InlineResponse2003|error {
        string resourcePath = string `/favorites`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Multiple Favorites
    #
    # + favoriteType - The favorite type
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType](DeleteFavoritesByTypeHeaders headers = {}, *DeleteFavoritesByTypeQueries queries) returns GenericResult|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Is Favorite
    #
    # + favoriteType - The favorite type
    # + favoriteId - Favorite Id, e.g., sheet Id, report Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object 
    resource isolated function get favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType]/[decimal favoriteId](IsFavoriteHeaders headers = {}, *IsFavoriteQueries queries) returns Favorite|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}/${getEncodedUri(favoriteId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Favorite
    #
    # + favoriteType - The favorite type
    # + favoriteId - Favorite Id, e.g., sheet Id, report Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete favorites/["folder"|"report"|"sheet"|"sight"|"template"|"workspace" favoriteType]/[decimal favoriteId](DeleteFavoritesByTypeAndIdHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/favorites/${getEncodedUri(favoriteType)}/${getEncodedUri(favoriteId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List filtered events
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post filteredEvents(FilteredEventsRequest payload, ListFilteredEventsHeaders headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/filteredEvents`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - A single Folder object 
    resource isolated function get folders/[decimal folderId](GetFolderHeaders headers = {}, *GetFolderQueries queries) returns Folder|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + return - Result object containing the modified Folder object 
    resource isolated function put folders/[decimal folderId](Folder payload, UpdateFolderHeaders headers = {}) returns InlineResponse2005|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete folders/[decimal folderId](DeleteFolderHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - New folder name 
    # + return - Result object containing a Folder object for the new folder destination 
    resource isolated function post folders/[decimal folderId]/copy(FolderIdCopyBody payload, CopyFolderHeaders headers = {}, *CopyFolderQueries queries) returns ContainerDestinationForCopy|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Folders
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Folder objects 
    resource isolated function get folders/[decimal folderId]/folders(ListFoldersHeaders headers = {}, *ListFoldersQueries queries) returns InlineResponse2006|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Folder to create 
    # + return - Result object containing a Folder object for newly created folder 
    resource isolated function post folders/[decimal folderId]/folders(FolderIdFoldersBody payload, CreateFolderFolderHeaders headers = {}, *CreateFolderFolderQueries queries) returns InlineResponse2007|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + payload - New folder destination 
    # + return - Result object containing a Folder object for the new folder destination 
    resource isolated function post folders/[decimal folderId]/move(FolderIdMoveBody payload, MoveFolderHeaders headers = {}) returns ContainerDestinationForMove|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create Sheet in Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Sheet to create 
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request 
    resource isolated function post folders/[decimal folderId]/sheets(FolderIdSheetsBody payload, CreateSheetInFolderHeaders headers = {}, *CreateSheetInFolderQueries queries) returns InlineResponse2008|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet into Folder
    #
    # + folderId - Folder Id where you can create sheets, sights, reports, templates, and other folders
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Binary content for the CSV / XLSX file 
    # + return - Result object containing a Sheet object for imported sheet 
    resource isolated function post folders/[decimal folderId]/sheets/'import(ImportSheetIntoFolderHeaders headers, byte[] payload, *ImportSheetIntoFolderQueries queries) returns InlineResponse2009|error {
        string resourcePath = string `/folders/${getEncodedUri(folderId)}/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Contents
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - A single Home object 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get folders/personal(ListHomeContentsHeaders headers = {}, *ListHomeContentsQueries queries) returns Home|error {
        string resourcePath = string `/folders/personal`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Org Groups
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of [Group objects](/api/smartsheet/openapi/groups/group) 
    resource isolated function get groups(ListGroupsHeaders headers = {}, *ListGroupsQueries queries) returns InlineResponse20010|error {
        string resourcePath = string `/groups`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Group
    #
    # + headers - Headers to be sent with the request 
    # + payload - [Group object](/api/smartsheet/openapi/groups/group), limited to the following attributes: 
    # + return - Result object, containing a [Group object](/api/smartsheet/openapi/groups/group) for the newly created group 
    resource isolated function post groups(GroupCreate1 payload, AddGroupHeaders headers = {}) returns InlineResponse20011|error {
        string resourcePath = string `/groups`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request 
    # + return - [Group](/api/smartsheet/openapi/groups/group) object that includes the list of [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) objects 
    resource isolated function get groups/[decimal groupId](GetGroupHeaders headers = {}) returns InlineResponse20012|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request 
    # + payload - Group object, limited to the following attributes: 
    # + return - Result object containing the [Group object](/api/smartsheet/openapi/groups/group) for the updated group 
    resource isolated function put groups/[decimal groupId](GroupUpdate1 payload, UpdateGroupHeaders headers = {}) returns InlineResponse20011|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Group
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request 
    # + return - **_This operation is asynchronous,_** _meaning group members may retain their sharing access for a brief period of time after the call returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._ 
    resource isolated function delete groups/[decimal groupId](DeleteGroupHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Add Group Members
    #
    # + groupId - Group Id
    # + headers - Headers to be sent with the request 
    # + return - Returns a Result object containing the members added to the group -- either a single [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) or array of [GroupMember](/api/smartsheet/openapi/groupmembers/groupmember) objects, corresponding to what was specified in the request. **_This operation is asynchronous,_** _meaning the users may not yet have sharing access to sheets for a period of time after this operation returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._ 
    resource isolated function post groups/[decimal groupId]/members(GroupIdMembersBody payload, AddGroupMembersHeaders headers = {}) returns InlineResponse20013|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Group Members
    #
    # + groupId - Group Id
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - **_This operation is asynchronous,_** _meaning the users may not yet have sharing access to sheets for a period of time after this operation returns. For small groups with limited sharing, the operation should complete quickly (within a few seconds). For large groups with many shares, this operation could possibly take more than a minute to complete._ 
    resource isolated function delete groups/[decimal groupId]/members/[decimal userId](DeleteGroupMembersHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/groups/${getEncodedUri(groupId)}/members/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Folders in Home
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Folder objects 
    resource isolated function get home/folders(HomeListFoldersHeaders headers = {}, *HomeListFoldersQueries queries) returns InlineResponse2006|error {
        string resourcePath = string `/home/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Folder
    #
    # + headers - Headers to be sent with the request 
    # + payload - Folder to create 
    # + return - Result object containing a Folder object for newly created folder 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post home/folders(HomeFoldersBody payload, CreateHomeFolderHeaders headers = {}) returns InlineResponse2007|error {
        string resourcePath = string `/home/folders`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Image URLs
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post imageurls(InlineBodyItemsApplicationjsonimageurls[] payload, ListImageUrlsHeaders headers = {}) returns InlineResponse20014|error {
        string resourcePath = string `/imageurls`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Reports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Object containing an array of all accessible reports, referenced by their ID, name, access level, and summary report flag values 
    resource isolated function get reports(GetReportsHeaders headers = {}, *GetReportsQueries queries) returns InlineResponse20015|error {
        string resourcePath = string `/reports`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Report
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The Report that was loaded 
    resource isolated function get reports/[decimal reportId](GetReportHeaders headers = {}, *GetReportQueries queries) returns Report|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Send report via email
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + return - Result Object 
    resource isolated function post reports/[decimal reportId]/emails(SheetEmail payload, SendReportViaEmailHeaders headers = {}) returns Result|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Gets a Report's publish settings
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + return - The Report's publish settings 
    resource isolated function get reports/[decimal reportId]/publish(GetReportPublishHeaders headers = {}) returns ReportPublish|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set a Report's publish status
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + return - ReportPublish object 
    resource isolated function put reports/[decimal reportId]/publish(ReportPublish payload, SetReportPublishHeaders headers = {}) returns InlineResponse20016|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Report Shares
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (include=workspaceShares) also be returned 
    resource isolated function get reports/[decimal reportId]/shares(ListReportSharesHeaders headers = {}, *ListReportSharesQueries queries) returns InlineResponse20017|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Report
    #
    # + reportId - reportID of the report being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM 
    resource isolated function post reports/[decimal reportId]/shares(ReportIdSharesBody payload, ShareReportHeaders headers = {}, *ShareReportQueries queries) returns InlineResponse20018|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Share object 
    resource isolated function get reports/[decimal reportId]/shares/[string shareId](ShareReportGetHeaders headers = {}, *ShareReportGetQueries queries) returns Share|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing the modified Share object 
    resource isolated function put reports/[decimal reportId]/shares/[string shareId](SharesshareIdBody payload, UpdateReportShareHeaders headers = {}, *UpdateReportShareQueries queries) returns InlineResponse20019|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Report Share
    #
    # + reportId - reportID of the report being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete reports/[decimal reportId]/shares/[string shareId](DeleteReportShareHeaders headers = {}, *DeleteReportShareQueries queries) returns Result|error {
        string resourcePath = string `/reports/${getEncodedUri(reportId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Search Everything
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SearchResult object that contains an array of Search objects (maximum 100) 
    resource isolated function get search(ListSearchHeaders headers = {}, *ListSearchQueries queries) returns InlineResponse20020|error {
        string resourcePath = string `/search`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}, "scopes": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SearchResult object containing an array of SearchResultItem objects in a sheet (maximum 100) 
    resource isolated function get search/sheets/[decimal sheetId](ListSearchSheetHeaders headers = {}, *ListSearchSheetQueries queries) returns InlineResponse20021|error {
        string resourcePath = string `/search/sheets/${getEncodedUri(sheetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Gets application constants.
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get serverinfo(map<string|string[]> headers = {}) returns ServerInfo|error {
        string resourcePath = string `/serverinfo`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Sheets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets(ListSheetsHeaders headers = {}, *ListSheetsQueries queries) returns InlineResponse20022|error {
        string resourcePath = string `/sheets`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Sheet in "Sheets" Folder
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Sheet to create 
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post sheets(SheetsBody payload, CreateSheetInSheetsFolderHeaders headers = {}, *CreateSheetInSheetsFolderQueries queries) returns InlineResponse2008|error {
        string resourcePath = string `/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet from CSV / XLSX
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Binary content for the CSV / XLSX file 
    # + return - Result object containing a Sheet object for imported sheet 
    # 
    # # Deprecated
    @deprecated
    resource isolated function post sheets/'import(ImportSheetIntoSheetsFolderHeaders headers, byte[] payload, *ImportSheetIntoSheetsFolderQueries queries) returns InlineResponse2009|error {
        string resourcePath = string `/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The Sheet that was loaded 
    resource isolated function get sheets/[decimal sheetId](GetSheetHeaders headers = {}, *GetSheetQueries queries) returns InlineResponse20023|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        map<Encoding> queryParamEncoding = {"rowsModifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - [Sheet object](/api/smartsheet/openapi/sheets/sheet) limited to the following attributes: 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing a [Sheet object](/api/smartsheet/openapi/sheets/sheet) for the updated sheet 
    resource isolated function put sheets/[decimal sheetId](UpdateSheet payload, UpdateSheetHeaders headers = {}, *UpdateSheetQueries queries) returns InlineResponse20024|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId](DeleteSheetHeaders headers = {}) returns SuccessResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/attachments(AttachmentsListOnSheetHeaders headers = {}, *AttachmentsListOnSheetQueries queries) returns InlineResponse20025|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File or URL to Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/attachments(byte[] payload, AttachmentsAttachToSheetHeaders headers = {}) returns InlineResponse20026|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Attachment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets/[decimal sheetId]/attachments/[string attachmentId](AttachmentsGetHeaders headers = {}) returns InlineResponse20027|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Attachment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/attachments/[string attachmentId](AttachmentsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(AttachmentsVersionListHeaders headers = {}, *AttachmentsVersionListQueries queries) returns InlineResponse20025|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach New version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(byte[] payload, AttachmentsVersionUploadHeaders headers = {}) returns InlineResponse20026|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete All Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + attachmentId - ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/attachments/[string attachmentId]/versions(AttachmentsVersionsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/attachments/${getEncodedUri(attachmentId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List All Automation Rules
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The list of AutomationRule objects 
    resource isolated function get sheets/[decimal sheetId]/automationrules(AutomationrulesListHeaders headers = {}, *AutomationrulesListQueries queries) returns InlineResponse20028|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request 
    # + return - AutomationRule object 
    resource isolated function get sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationruleGetHeaders headers = {}) returns InlineResponse20029|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request 
    # + return - Result object containing the updated AutomationRule object 
    resource isolated function put sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationRule payload, AutomationruleUpdateHeaders headers = {}) returns InlineResponse20030|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete an Automation Rule
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + automationRuleId - The Id of an Automation Rule
    # + headers - Headers to be sent with the request 
    # + return - Result object 
    resource isolated function delete sheets/[decimal sheetId]/automationrules/[string automationRuleId](AutomationruleDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/automationrules/${getEncodedUri(automationRuleId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Columns
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns [IndexResult object]() containing an array of [Column objects]() 
    resource isolated function get sheets/[decimal sheetId]/columns(ColumnsListOnSheetHeaders headers = {}, *ColumnsListOnSheetQueries queries) returns InlineResponse20031|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Columns
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - A [Column object]() that contains the following attributes 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the newly created columns -- either a single [Column object](/api/smartsheet/openapi/columns/column) or an array of Column objects, corresponding to what was specified in the request 
    resource isolated function post sheets/[decimal sheetId]/columns(ColumnObjectAttributes payload, ColumnsAddToSheetHeaders headers = {}) returns InlineResponse20032|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets/[decimal sheetId]/columns/[decimal columnId](ColumnGetHeaders headers = {}, *ColumnGetQueries queries) returns InlineResponse20033|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - A [Column object]() that contains the following attributes: 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the [Column object](/api/smartsheet/openapi/columns/column) that was modified 
    resource isolated function put sheets/[decimal sheetId]/columns/[decimal columnId](ColumnObjectAttributes payload, ColumnUpdateColumnHeaders headers = {}) returns InlineResponse20034|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Column
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/columns/[decimal columnId](ColumnDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/columns/${getEncodedUri(columnId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets/[decimal sheetId]/comments/[string commentId](CommentGetHeaders headers = {}) returns InlineResponse20035|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Edit a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function put sheets/[decimal sheetId]/comments/[string commentId](CommentCreationRequest payload, CommentEditHeaders headers = {}) returns InlineResponse20036|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/comments/[string commentId](CommentDeleteHeaders headers = {}) returns InlineResponse20037|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Attach File or URL to Comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + commentId - ID of the comment
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/comments/[string commentId]/attachments(byte[] payload, AttachmentsAttachToCommentHeaders headers = {}) returns InlineResponse20026|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/comments/${getEncodedUri(commentId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Copy Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Destination where to create a copy of the specified sheet 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/copy(ContainerDestinationForCopy payload, CopySheetHeaders headers = {}, *CopySheetQueries queries) returns InlineResponse20038|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Cross-sheet References
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of CrossSheetReference objects 
    resource isolated function get sheets/[decimal sheetId]/crosssheetreferences(ListCrosssheetReferencesHeaders headers = {}, *ListCrosssheetReferencesQueries queries) returns InlineResponse20039|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Cross-sheet References
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - CrossSheetReference object to create 
    # + return - Result object containing a CrossSheetReference object, corresponding to what was specified in the request 
    resource isolated function post sheets/[decimal sheetId]/crosssheetreferences(SheetIdCrosssheetreferencesBody payload, AddCrosssheetReferenceHeaders headers = {}) returns InlineResponse20040|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Cross-sheet Reference
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + crossSheetReferenceId - Cross-sheet Reference Id
    # + headers - Headers to be sent with the request 
    # + return - CrossSheetReference object 
    resource isolated function get sheets/[decimal sheetId]/crosssheetreferences/[decimal crossSheetReferenceId](GetCrosssheetReferenceHeaders headers = {}) returns CrossSheetReference|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/crosssheetreferences/${getEncodedUri(crossSheetReferenceId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Discussions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/discussions(DiscussionsListHeaders headers = {}, *DiscussionsListQueries queries) returns InlineResponse20041|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/discussions(DiscussionCreationRequest payload, DiscussionsCreateHeaders headers = {}) returns InlineResponse20042|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets/[decimal sheetId]/discussions/[string discussionId](DiscussionGetHeaders headers = {}) returns InlineResponse20043|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete a Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/discussions/[string discussionId](DiscussionDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Discussion Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/discussions/[string discussionId]/attachments(DiscussionListAttachmentsHeaders headers = {}, *DiscussionListAttachmentsQueries queries) returns InlineResponse20025|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a comment
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + discussionId - ID of the discussion
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/discussions/[string discussionId]/comments(CommentCreationRequest payload, CommentsCreateHeaders headers = {}) returns InlineResponse20044|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/discussions/${getEncodedUri(discussionId)}/comments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Send Sheet via Email
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - [SheetEmail object](/api/smartsheet/openapi/sendviaemail/sheetemail) 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/emails(SheetEmail payload, SheetSendHeaders headers = {}) returns InlineResponse20045|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - Destination to move the specified sheet 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/move(ContainerDestinationForMove payload, MoveSheetHeaders headers = {}) returns InlineResponse20038|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proofs
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/proofs(ProofsGetAllProofsHeaders headers = {}, *ProofsGetAllProofsQueries queries) returns InlineResponse20046|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId](ProofsGetHeaders headers = {}, *ProofsGetQueries queries) returns InlineResponse20047|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Proof Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function put sheets/[decimal sheetId]/proofs/[string proofId](UpdateProofStatusRequest payload, ProofsUpdateHeaders headers = {}) returns InlineResponse20047|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId](ProofsDeleteHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Proof Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/attachments(ProofsListAttachmentsHeaders headers = {}, *ProofsListAttachmentsQueries queries) returns InlineResponse20048|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File to Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/attachments(byte[] payload, ProofsAttachToProofHeaders headers = {}) returns InlineResponse20026|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proof Discussions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/discussions(ProofsListDiscussionsHeaders headers = {}, *ProofsListDiscussionsQueries queries) returns InlineResponse20049|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Discussion
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/discussions(DiscussionCreationRequest payload, ProofsCreateDiscussionHeaders headers = {}) returns InlineResponse20042|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Proof Request Actions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/requestactions(ProofsListRequestActionsHeaders headers = {}, *ProofsListRequestActionsQueries queries) returns InlineResponse20050|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requestactions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/requests(ProofRequestBody payload, ProofsCreateProofRequestsHeaders headers = {}) returns InlineResponse20051|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Proof Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId]/requests(ProofsDeleteProofRequestsHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/requests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Proof Versions
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/proofs/[string proofId]/versions(ProofsGetVersionsHeaders headers = {}, *ProofsGetVersionsQueries queries) returns InlineResponse20052|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Proof Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/proofs/[string proofId]/versions(byte[] payload, ProofsCreateVersionHeaders headers = {}) returns InlineResponse20053|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Proof Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + proofId - Proof Id of the original proof
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete sheets/[decimal sheetId]/proofs/[string proofId]/versions(ProofsDeleteVersionHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/proofs/${getEncodedUri(proofId)}/versions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get Sheet Publish Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/publish(GetSheetPublishHeaders headers = {}) returns SheetPublish|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Sheet Publish Status
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - SheetPublish object 
    # + return - OK 
    resource isolated function put sheets/[decimal sheetId]/publish(SheetPublishRequest payload, SetSheetPublishHeaders headers = {}) returns InlineResponse20054|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Update Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - [Row object](/api/smartsheet/openapi/rows/row) or an array of Row objects, with the following attributes: 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing an array of the updated rows 
    resource isolated function put sheets/[decimal sheetId]/rows(SheetIdRowsBody payload, UpdateRowsHeaders headers = {}, *UpdateRowsQueries queries) returns InlineResponse20055|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Add Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - [Row object](/api/smartsheet/openapi/rows/row) or an array of Row objects, with the following attributes: 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing the newly created rows -- either a single [Row object](/api/smartsheet/openapi/rows/row) or array of Row objects, corresponding to what was specified in the request, as well as the new version of the sheet 
    resource isolated function post sheets/[decimal sheetId]/rows(SheetIdRowsBody1 payload, RowsAddToSheetHeaders headers = {}, *RowsAddToSheetQueries queries) returns InlineResponse20056|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Rows
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns [Result object](/api/smartsheet/openapi/schemas/result) containing row Ids corresponding to all rows that were successfully deleted (including any child rows of rows specified in the URL) 
    resource isolated function delete sheets/[decimal sheetId]/rows(DeleteRowsHeaders headers = {}, *DeleteRowsQueries queries) returns InlineResponse20057|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Send Rows via Email
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - The columns included for each row in the email are populated according to the following rules: 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/rows/emails(MultiRowEmail payload, RowsSendHeaders headers = {}) returns InlineResponse20045|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/emails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Copy Rows to Another Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CopyOrMoveRowResult object 
    resource isolated function post sheets/[decimal sheetId]/rows/copy(CopyOrMoveRowDirective payload, CopyRowsHeaders headers = {}, *CopyRowsQueries queries) returns CopyOrMoveRowResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Rows to Another Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - CopyOrMoveRowResult object 
    resource isolated function post sheets/[decimal sheetId]/rows/move(CopyOrMoveRowDirective payload, MoveRowsHeaders headers = {}, *MoveRowsQueries queries) returns CopyOrMoveRowResult|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/move`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns [Row object]() populated according to the specified parameters 
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId](RowGetHeaders headers = {}, *RowGetQueries queries) returns InlineResponse20058|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Row Attachments
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/attachments(AttachmentsListOnRowHeaders headers = {}, *AttachmentsListOnRowQueries queries) returns InlineResponse20025|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/attachments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Attach File or URL to Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/attachments(byte[] payload, RowAttachmentsAttachFileHeaders headers = {}) returns InlineResponse20026|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Add Image to Cell
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/columns/[decimal columnId]/cellimages(byte[] payload, AddImageToCellHeaders headers = {}, *AddImageToCellQueries queries) returns InlineResponse20059|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/columns/${getEncodedUri(columnId)}/cellimages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Cell History
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + columnId - Column Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/columns/[decimal columnId]/history(CellHistoryGetHeaders headers = {}, *CellHistoryGetQueries queries) returns InlineResponse20060|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/columns/${getEncodedUri(columnId)}/history`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Discussions with a Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/rows/[decimal rowId]/discussions(RowDiscussionsListHeaders headers = {}, *RowDiscussionsListQueries queries) returns InlineResponse20041|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/discussions`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Discussion on a Row
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/discussions(DiscussionCreationRequest payload, RowDiscussionsCreateHeaders headers = {}) returns InlineResponse20042|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/discussions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create Proof
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + rowId - Row Id in the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/rows/[decimal rowId]/proofs(byte[] payload, ProofsCreateHeaders headers = {}) returns InlineResponse20053|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/rows/${getEncodedUri(rowId)}/proofs`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Sent Update Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The list of SentUpdateRequest objects 
    resource isolated function get sheets/[decimal sheetId]/sentupdaterequests(SentupdaterequestsListHeaders headers = {}, *SentupdaterequestsListQueries queries) returns InlineResponse20061|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Sent Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + sentUpdateRequestId - ID of the sent update request
    # + headers - Headers to be sent with the request 
    # + return - SentUpdateRequest object 
    resource isolated function get sheets/[decimal sheetId]/sentupdaterequests/[string sentUpdateRequestId](SentupdaterequestGetHeaders headers = {}) returns SentUpdateRequest|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests/${getEncodedUri(sentUpdateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Sent Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + sentUpdateRequestId - ID of the sent update request
    # + headers - Headers to be sent with the request 
    # + return - Result object 
    resource isolated function delete sheets/[decimal sheetId]/sentupdaterequests/[string sentUpdateRequestId](SentupdaterequestDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sentupdaterequests/${getEncodedUri(sentUpdateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get Sheet Summary
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/summary(ListSummaryFieldsHeaders headers = {}, *ListSummaryFieldsQueries queries) returns SheetSummary|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/summary/fields(ListSummaryFieldsPaginatedHeaders headers = {}, *ListSummaryFieldsPaginatedQueries queries) returns InlineResponse20062|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Array of SummaryField objects 
    # + return - OK 
    resource isolated function put sheets/[decimal sheetId]/summary/fields(SummaryFieldUpdateRequest[] payload, UpdateSummaryFieldsHeaders headers = {}, *UpdateSummaryFieldsQueries queries) returns InlineResponse20063|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Add Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Array of SummaryField objects 
    # + return - OK 
    resource isolated function post sheets/[decimal sheetId]/summary/fields(SummaryFieldCreateRequest[] payload, AddSummaryFieldsHeaders headers = {}, *AddSummaryFieldsQueries queries) returns InlineResponse20064|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Summary Fields
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function delete sheets/[decimal sheetId]/summary/fields(DeleteSummaryFieldsHeaders headers = {}, *DeleteSummaryFieldsQueries queries) returns InlineResponse20065|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Add Image to Sheet Summary
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + fieldId - Summary Field Id of the sheet summary field being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function post sheets/[decimal sheetId]/summary/fields/[decimal fieldId]/images(byte[] payload, AddImageSummaryFieldHeaders headers = {}, *AddImageSummaryFieldQueries queries) returns InlineResponse20066|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/summary/fields/${getEncodedUri(fieldId)}/images`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Update Requests
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The list of UpdateRequest objects 
    resource isolated function get sheets/[decimal sheetId]/updaterequests(UpdaterequestsListHeaders headers = {}, *UpdaterequestsListQueries queries) returns InlineResponse20067|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - Result object containing the newly created UpdateRequest object 
    resource isolated function post sheets/[decimal sheetId]/updaterequests(UpdateRequest payload, UpdaterequestsCreateHeaders headers = {}) returns InlineResponse20068|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request 
    # + return - UpdateRequest object 
    resource isolated function get sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsGetHeaders headers = {}) returns UpdateRequest|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request 
    # + return - Result object containing the modified UpdateRequest object 
    resource isolated function put sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsUpdateHeaders headers = {}) returns InlineResponse20068|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete an Update Request
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + updateRequestId - ID of the Update Request
    # + headers - Headers to be sent with the request 
    # + return - Result object 
    resource isolated function delete sheets/[decimal sheetId]/updaterequests/[string updateRequestId](UpdaterequestsDeleteHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/updaterequests/${getEncodedUri(updateRequestId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Sheet Shares
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (include=workspaceShares) also be returned 
    resource isolated function get sheets/[decimal sheetId]/shares(ListSheetSharesHeaders headers = {}, *ListSheetSharesQueries queries) returns InlineResponse20017|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM 
    resource isolated function post sheets/[decimal sheetId]/shares(SheetIdSharesBody payload, ShareSheetHeaders headers = {}, *ShareSheetQueries queries) returns InlineResponse20018|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet Share.
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Share object 
    resource isolated function get sheets/[decimal sheetId]/shares/[string shareId](ShareSheetGetHeaders headers = {}, *ShareSheetGetQueries queries) returns Share|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Sheet Share.
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object containing the modified Share object 
    resource isolated function put sheets/[decimal sheetId]/shares/[string shareId](SharesshareIdBody payload, UpdateSheetShareHeaders headers = {}, *UpdateSheetShareQueries queries) returns InlineResponse20019|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Sheet Share
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete sheets/[decimal sheetId]/shares/[string shareId](DeleteSheetShareHeaders headers = {}, *DeleteSheetShareQueries queries) returns Result|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Sort Rows in Sheet
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - [SortSpecifier](/api/smartsheet/openapi/schemas/sortspecifier) with the following attribute: 
    # + return - Returns [Sheet object](/api/smartsheet/openapi/sheets/sheet), populated according to the specified parameters 
    resource isolated function post sheets/[decimal sheetId]/sort(SortSpecifier payload, RowsSortHeaders headers = {}, *RowsSortQueries queries) returns InlineResponse20069|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/sort`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Sheet Version
    #
    # + sheetId - Sheet Id of the sheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function get sheets/[decimal sheetId]/version(GetSheetVersionHeaders headers = {}) returns SheetVersion|error {
        string resourcePath = string `/sheets/${getEncodedUri(sheetId)}/version`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Dashboards
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Dashboard objects with a subset of attributes 
    resource isolated function get sights(ListSightsHeaders headers = {}, *ListSightsQueries queries) returns InlineResponse20070|error {
        string resourcePath = string `/sights`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Dashboard object 
    resource isolated function get sights/[string sightId](GetSightHeaders headers = {}, *GetSightQueries queries) returns Sight|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing the updated Dashboard object 
    resource isolated function put sights/[string sightId](SightName payload, UpdateSightHeaders headers = {}, *UpdateSightQueries queries) returns InlineResponse20071|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + return - Generic response result 
    resource isolated function delete sights/[string sightId](DeleteSightHeaders headers = {}) returns InlineResponse20045|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + return - Result object containing a dashboard with a subset of attributes for the newly created dashboard 
    resource isolated function post sights/[string sightId]/copy(ContainerDestinationForCopy payload, CopySightHeaders headers = {}) returns InlineResponse20072|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/copy`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Move Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + return - Result object containing a Dashboard object with a subset of attributes for the moved dashboard 
    resource isolated function post sights/[string sightId]/move(ContainerDestinationForMove payload, MoveSightHeaders headers = {}) returns InlineResponse20072|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/move`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Dashboard Publish Status
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + return - SightPublish object 
    resource isolated function get sights/[string sightId]/publish(GetSightPublishStatusHeaders headers = {}) returns SightPublish|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Dashboard Publish Status
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + return - SightPublish object 
    resource isolated function put sights/[string sightId]/publish(SightPublish payload, SetSightPublishStatusHeaders headers = {}) returns InlineResponse20073|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/publish`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Dashboard Shares
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Share objects. By default, this operation returns only item-level shares (scope=ITEM). Use the sharingInclude parameter to request that workspace-level shares (scope=WORKSPACE) also be returned 
    resource isolated function get sights/[string sightId]/shares(ListSightSharesHeaders headers = {}, *ListSightSharesQueries queries) returns InlineResponse20017|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Dashboard
    #
    # + sightId - SightID of the sight being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing either a single Share object or an array of Share objects, corresponding to what was specified in the request. All shares have scope=ITEM 
    resource isolated function post sights/[string sightId]/shares(Share payload, ShareSightHeaders headers = {}, *ShareSightQueries queries) returns InlineResponse20018|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Share object 
    resource isolated function get sights/[string sightId]/shares/[string shareId](ShareSightGetHeaders headers = {}, *ShareSightGetQueries queries) returns Share|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object containing the modified Share object 
    resource isolated function put sights/[string sightId]/shares/[string shareId](SharesshareIdBody payload, UpdateSightShareHeaders headers = {}, *UpdateSightShareQueries queries) returns InlineResponse20019|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Dashboard Share
    #
    # + sightId - SightID of the sight being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete sights/[string sightId]/shares/[string shareId](DeleteSightShareHeaders headers = {}) returns Result|error {
        string resourcePath = string `/sights/${getEncodedUri(sightId)}/shares/${getEncodedUri(shareId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List User-Created Templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get templates(TemplatesListHeaders headers = {}, *TemplatesListQueries queries) returns InlineResponse20074|error {
        string resourcePath = string `/templates`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Public Templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function get templates/'public(TemplatesListPublicHeaders headers = {}, *TemplatesListPublicQueries queries) returns InlineResponse20074|error {
        string resourcePath = string `/templates/public`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Gets or Refreshes an Access Token
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - An access token 
    resource isolated function post token(TokensGetOrRefreshHeaders headers = {}, *TokensGetOrRefreshQueries queries) returns Token|error {
        string resourcePath = string `/token`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Revoke Access Token
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - SUCCESS 
    resource isolated function delete token(TokensDeleteHeaders headers = {}, *TokensDeleteQueries queries) returns Result|error {
        string resourcePath = string `/token`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of [User objects](/api/smartsheet/openapi/users/user) 
    resource isolated function get users(ListUsersHeaders headers = {}, *ListUsersQueries queries) returns InlineResponse20075|error {
        string resourcePath = string `/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add User
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - The User to be created 
    # + return - Result object containing the newly created [User object](/api/smartsheet/openapi/users/user) 
    resource isolated function post users(User payload, AddUserHeaders headers = {}, *AddUserQueries queries) returns InlineResponse20076|error {
        string resourcePath = string `/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Current User
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResultUnknownPages object containing a UserProfile object 
    resource isolated function get users/me(GetCurrentUserHeaders headers = {}, *GetCurrentUserQueries queries) returns InlineResponse20077|error {
        string resourcePath = string `/users/me`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Org Sheets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResultUnknownPages object containing an array of Sheet objects, limited to the following attributes: * id * name * owner: empty string * ownerId: (static "0") 
    resource isolated function get users/sheets(ListOrgSheetsHeaders headers = {}, *ListOrgSheetsQueries queries) returns InlineResponse20078|error {
        string resourcePath = string `/users/sheets`;
        map<Encoding> queryParamEncoding = {"modifiedSince": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - Returns UserProfile object 
    resource isolated function get users/[decimal userId](GetUserHeaders headers = {}) returns UserProfile|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + payload - User object containing at least one of the following attributes: 
    # + return - Result object containing the [User object](/api/smartsheet/openapi/users/user) for the updated user 
    resource isolated function put users/[decimal userId](UserUpdate payload, UpdateUserHeaders headers = {}) returns InlineResponse20079|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Remove User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete users/[decimal userId](RemoveUserHeaders headers = {}, *RemoveUserQueries queries) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Alternate Emails
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - IndexResult object containing an array of [AlternateEmail objects](/api/smartsheet/openapi/alternateemailaddress/alternateemail) 
    resource isolated function get users/[decimal userId]/alternateemails(ListAlternateEmailsHeaders headers = {}) returns InlineResponse20080|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Alternate Emails
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - Result object containing an array of the newly created [AlternateEmail objects](/api/smartsheet/openapi/alternateemailaddress/alternateemail) 
    resource isolated function post users/[decimal userId]/alternateemails(UserIdAlternateemailsBody payload, AddAlternateEmailHeaders headers = {}) returns InlineResponse20081|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Alternate Email
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request 
    # + return - Returns [AlternateEmail object](/api/smartsheet/openapi/alternateemailaddress/alternateemail) 
    resource isolated function get users/[decimal userId]/alternateemails/[decimal alternateEmailId](GetAlternateEmailHeaders headers = {}) returns AlternateEmail|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Alternate Email
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete users/[decimal userId]/alternateemails/[decimal alternateEmailId](DeleteAlternateEmailHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Make Alternate Email Primary
    #
    # + userId - User Id
    # + alternateEmailId - Alternate Email Id
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post users/[decimal userId]/alternateemails/[decimal alternateEmailId]/makeprimary(PromoteAlternateEmailHeaders headers = {}) returns InlineResponse20082|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/alternateemails/${getEncodedUri(alternateEmailId)}/makeprimary`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Deactivate User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function post users/[decimal userId]/deactivate(DeactivateUserHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/deactivate`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update User Profile Image
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function post users/[decimal userId]/profileimage(byte[] payload, UpdateUserProfileImageHeaders headers = {}) returns InlineResponse20079|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/profileimage`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Reactivate User
    #
    # + userId - User Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function post users/[decimal userId]/reactivate(ReactivateUserHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/users/${getEncodedUri(userId)}/reactivate`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Webhooks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - The List of Webhooks 
    resource isolated function get webhooks(ListWebhooksHeaders headers = {}, *ListWebhooksQueries queries) returns InlineResponse20083|error {
        string resourcePath = string `/webhooks`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Webhook
    #
    # + headers - Headers to be sent with the request 
    # + return - Result object, containing a Webhook object for the newly created webhook 
    resource isolated function post webhooks(WebhooksBody payload, CreateWebhookHeaders headers = {}) returns InlineResponse20084|error {
        string resourcePath = string `/webhooks`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request 
    # + return - Webhook object 
    resource isolated function get webhooks/[string webhookId](GetWebhookHeaders headers = {}) returns Webhook|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request 
    # + return - Result object containing the Webhook object for the updated webhook 
    resource isolated function put webhooks/[string webhookId](UpdateWebhookRequest payload, UpdateWebhookHeaders headers = {}) returns InlineResponse20084|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Webhook
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request 
    # + return - Result object 
    resource isolated function delete webhooks/[string webhookId](DeleteWebhookHeaders headers = {}) returns InlineResponse20085|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reset Shared Secret
    #
    # + webhookId - The Id of a Webhook
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post webhooks/[string webhookId]/resetSharedSecret(ResetSharedSecretHeaders headers = {}) returns InlineResponse20086|error {
        string resourcePath = string `/webhooks/${getEncodedUri(webhookId)}/resetSharedSecret`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspaces
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Workspace objects 
    resource isolated function get workspaces(ListWorkspacesHeaders headers = {}, *ListWorkspacesQueries queries) returns InlineResponse20087|error {
        string resourcePath = string `/workspaces`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Workspace
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Workspace to create 
    # + return - Result object containing a Workspace object for newly created workspace 
    resource isolated function post workspaces(WorkspacesBody payload, CreateWorkspaceHeaders headers = {}, *CreateWorkspaceQueries queries) returns InlineResponse20088|error {
        string resourcePath = string `/workspaces`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - A single Workspace object 
    resource isolated function get workspaces/[string workspaceId](GetWorkspaceHeaders headers = {}, *GetWorkspaceQueries queries) returns Workspace|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing the modified Workspace object 
    resource isolated function put workspaces/[string workspaceId](WorkspacesworkspaceIdBody payload, UpdateWorkspaceHeaders headers = {}, *UpdateWorkspaceQueries queries) returns InlineResponse20089|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete workspaces/[string workspaceId](DeleteWorkspaceHeaders headers = {}) returns GenericResult|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Copy Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - New workspace name 
    # + return - Result object containing a Workspace object for the new workspace destination 
    resource isolated function post workspaces/[string workspaceId]/copy(WorkspaceIdCopyBody payload, CopyWorkspaceHeaders headers = {}, *CopyWorkspaceQueries queries) returns ContainerDestinationForCopy|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/copy`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspace Folders
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - An array of Folder references 
    resource isolated function get workspaces/[string workspaceId]/folders(GetWorkspaceFoldersHeaders headers = {}, *GetWorkspaceFoldersQueries queries) returns InlineResponse20090|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/folders`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Folder
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + payload - Folder to create 
    # + return - Result object containing a Folder object for newly created folder 
    resource isolated function post workspaces/[string workspaceId]/folders(FolderNameOnly payload, CreateWorkspaceFolderHeaders headers = {}) returns InlineResponse20091|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/folders`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Workspace Shares
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - IndexResult object containing an array of Share objects 
    resource isolated function get workspaces/[string workspaceId]/shares(ListWorkspaceSharesHeaders headers = {}, *ListWorkspaceSharesQueries queries) returns InlineResponse20017|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Share Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - This operation supports both single-object and bulk semantics. For more information, see Optional Bulk Operations 
    resource isolated function post workspaces/[string workspaceId]/shares(WorkspaceIdSharesBody payload, ShareWorkspaceHeaders headers = {}, *ShareWorkspaceQueries queries) returns InlineResponse20018|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Returns Share object 
    resource isolated function get workspaces/[string workspaceId]/shares/[string shareId](ShareWorkspaceGetHeaders headers = {}, *ShareWorkspaceGetQueries queries) returns Share|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Result object containing the modified Share object 
    resource isolated function put workspaces/[string workspaceId]/shares/[string shareId](SharesshareIdBody payload, UpdateWorkspaceShareHeaders headers = {}, *UpdateWorkspaceShareQueries queries) returns InlineResponse20019|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Workspace Share
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + shareId - Share Id
    # + headers - Headers to be sent with the request 
    # + return - Returns Result object 
    resource isolated function delete workspaces/[string workspaceId]/shares/[string shareId](DeleteWorkspaceShareHeaders headers = {}) returns Result|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/shares/${getEncodedUri(shareId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Create Sheet in Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Sheet to create 
    # + return - Result object containing a Sheet object for newly created sheet, corresponding to what was specified in the request 
    resource isolated function post workspaces/[string workspaceId]/sheets(WorkspaceIdSheetsBody payload, CreateSheetInWorkspaceHeaders headers = {}, *CreateSheetInWorkspaceQueries queries) returns InlineResponse2008|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/sheets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Import Sheet into Workspace
    #
    # + workspaceId - WorkspaceID of the worksheet being accessed
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + payload - Binary content for the CSV / XLSX file 
    # + return - Result object containing a Sheet object for imported sheet 
    resource isolated function post workspaces/[string workspaceId]/sheets/'import(ImportSheetIntoWorkspaceHeaders headers, byte[] payload, *ImportSheetIntoWorkspaceQueries queries) returns InlineResponse2009|error {
        string resourcePath = string `/workspaces/${getEncodedUri(workspaceId)}/sheets/import`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }
}
