import ballerina/io;
import ballerinax/apple.music;

configurable string developerToken = ?;
configurable string musicUserToken = ?;
configurable string storefront = "us";

public function main() returns error? {
    music:Client appleMusic = check new ({
        authorization: developerToken,
        musicUserToken: musicUserToken
    });

    io:println("=== Music Discovery Service ===\n");

    string searchTerm = "indie+rock+alternative";
    io:println("1. Searching for songs with term: " + searchTerm);
    
    string[] searchTypes = ["songs", "artists"];
    music:SearchResponse searchResults = check appleMusic->/catalog/[storefront]/search(term = searchTerm, types = searchTypes, 'limit = 10);

    if searchResults.results.albums is () && searchResults.results.artists is () {
        io:println("No search results found");
        return;
    }

    if searchResults.results.artists is music:ArtistsResponse {
        music:ArtistsResponse artistsResponse = <music:ArtistsResponse>searchResults.results.artists;
        io:println("Found " + artistsResponse.data.length().toString() + " artists");
        foreach music:Artists artist in artistsResponse.data {
            io:println("  - Artist: " + artist.id);
        }
    }

    string sampleSongId = "1441164670";
    io:println("\n2. Getting detailed song information for ID: " + sampleSongId);
    
    string[] includeTypes = ["artists", "albums"];
    music:SongsResponse songDetails = check appleMusic->/catalog/[storefront]/songs/[sampleSongId](include = includeTypes);

    if songDetails.data.length() > 0 {
        music:Songs song = songDetails.data[0];
        io:println("Song ID: " + song.id);
        io:println("Song Type: " + song.'type);
        
        if song.attributes is music:SongsAttributes {
            music:SongsAttributes attrs = <music:SongsAttributes>song.attributes;
            io:println("Album: " + attrs.albumName);
            io:println("Genres: " + attrs.genreNames.toString());
            io:println("Duration: " + attrs.durationInMillis.toString() + " ms");
            if attrs.trackNumber is decimal {
                decimal trackNumber = <decimal>attrs.trackNumber;
                io:println("Track Number: " + trackNumber.toString());
            }
        }
    }

    io:println("\n3. Finding related artists for recommendations");
    
    music:SongsResponse relatedArtists = check appleMusic->/catalog/[storefront]/songs/[sampleSongId]/artists('limit = 5);

    io:println("Found " + relatedArtists.data.length().toString() + " related artist connections");
    foreach music:Songs relatedSong in relatedArtists.data {
        io:println("  - Related connection ID: " + relatedSong.id);
        io:println("    Type: " + relatedSong.'type);
    }

    io:println("\n4. Exploring genre connections");
    
    music:SongsResponse genreConnections = check appleMusic->/catalog/[storefront]/songs/[sampleSongId]/genres('limit = 3);

    io:println("Found " + genreConnections.data.length().toString() + " genre connections");
    foreach music:Songs genreConnection in genreConnections.data {
        io:println("  - Genre connection ID: " + genreConnection.id);
        if genreConnection.attributes is music:SongsAttributes {
            music:SongsAttributes genreAttrs = <music:SongsAttributes>genreConnection.attributes;
            io:println("    Genres: " + genreAttrs.genreNames.toString());
        }
    }

    io:println("\n=== Music Discovery Complete ===");
    io:println("Recommendation engine can now use this data to:");
    io:println("- Build user profiles based on genre preferences");
    io:println("- Suggest similar artists and tracks");
    io:println("- Create personalized playlists");
}