// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Use Apple Music API to access information about media in the Apple Music Catalog and a user's personal iCloud Music Library.
# * Apple Music Catalog includes all resources available in Apple Music.
# * iCloud Music Library contains only those resources the user adds to their personal library. For example, it contains items from Apple Music, songs purchased from iTunes Store, and imports from discs and other apps. This library can include content that's not in the Apple Music Catalog.
# Use this API to retrieve information about albums, songs, artists, playlists, music videos, Apple Music stations, ratings, charts, recommendations, and the user's most-recently played content. With proper authorization from the user, you can also create or modify playlists and apply ratings to the user's content.
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + apiKeyConfig - API keys for authorization 
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ApiKeysConfig apiKeyConfig, ConnectionConfig config =  {}, string serviceUrl = "https://api.music.apple.com/v1") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
        self.apiKeyConfig = apiKeyConfig.cloneReadOnly();
    }

    # Get Multiple Catalog Albums
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/albums(map<string|string[]> headers = {}, *GetAlbumsFromCatalogQueries queries) returns AlbumsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/albums`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "filter": {style: FORM, explode: true}, "include": {style: FORM, explode: true}, "restrict": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Album
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the album
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/albums/[string id](map<string|string[]> headers = {}, *GetAlbumFromCatalogQueries queries) returns AlbumsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/albums/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"views": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Album's Relationship Directly by Name
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the album
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/albums/[string id]/["artists"|"genres"|"library"|"record-labels"|"tracks" relationship](map<string|string[]> headers = {}, *GetAlbumRelationshipFromCatalogQueries queries) returns ArtistsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/albums/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Album's Relationship View Directly by Name
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the album
    # + view - The name of the resource view to fetch
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/albums/[string id]/view/["appears-on"|"other-versions"|"related-albums"|"related-videos" view](map<string|string[]> headers = {}, *GetAlbumViewFromCatalogQueries queries) returns MusicVideosResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/albums/${getEncodedUri(id)}/view/${getEncodedUri(view)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}, "with": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Multiple Catalog Artists
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/artists(map<string|string[]> headers = {}, *GetArtistsFromCatalogQueries queries) returns ArtistsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/artists`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "filter": {style: FORM, explode: true}, "include": {style: FORM, explode: true}, "restrict": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Artist
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the artist
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/artists/[string id](map<string|string[]> headers = {}, *GetArtistFromCatalogQueries queries) returns ArtistsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/artists/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"views": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Artist's Relationship Directly by Name
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the artist
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/artists/[string id]/["albums"|"genres"|"music-videos"|"playlists"|"station" relationship](map<string|string[]> headers = {}, *GetArtistRelationshipFromCatalogQueries queries) returns AlbumsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/artists/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Artist's Relationship View Directly by Name
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the artist
    # + view - The name of the resource view to fetch
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/artists/[string id]/view/["appears-on-albums"|"compilation-albums"|"featured-albums"|"featured-playlists"|"full-albums"|"latest-release"|"live-albums"|"similar-artists"|"singles"|"top-music-videos"|"top-songs" view](map<string|string[]> headers = {}, *GetArtistViewFromCatalogQueries queries) returns AlbumsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/artists/${getEncodedUri(id)}/view/${getEncodedUri(view)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}, "with": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search for Catalog Resources
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/search(map<string|string[]> headers = {}, *GetSearchResponseFromCatalogQueries queries) returns SearchResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/search`;
        map<Encoding> queryParamEncoding = {"types": {style: FORM, explode: true}, "with": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get Multiple Catalog Songs by ID
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/songs(map<string|string[]> headers = {}, *GetSongsFromCatalogQueries queries) returns SongsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/songs`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "filter": {style: FORM, explode: true}, "include": {style: FORM, explode: true}, "restrict": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Song
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the song
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/songs/[string id](map<string|string[]> headers = {}, *GetSongFromCatalogQueries queries) returns SongsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/songs/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Catalog Song's Relationship Directly by Name
    #
    # + storefront - An iTunes Store territory, specified by an ISO 3166 alpha-2 country code. The possible values are the id attributes of Storefront objects
    # + id - The unique identifier for the song
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get catalog/[string storefront]/songs/[string id]/["albums"|"artists"|"composers"|"genres"|"library"|"music-videos"|"station" relationship](map<string|string[]> headers = {}, *GetSongsRelationshipFromCatalogQueries queries) returns SongsResponse|error {
        string resourcePath = string `/catalog/${getEncodedUri(storefront)}/songs/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add a Resource to a Library
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Accepted 
    resource isolated function post me/library(map<string|string[]> headers = {}, *AddToLibraryQueries queries) returns error? {
        string resourcePath = string `/me/library`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Get All Library Albums
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/albums(map<string|string[]> headers = {}, *GetAlbumsFromLibraryQueries queries) returns LibraryAlbumsResponse|error {
        string resourcePath = string `/me/library/albums`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Album
    #
    # + id - The unique identifier for the album
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/albums/[string id](map<string|string[]> headers = {}, *GetAlbumFromLibraryQueries queries) returns LibraryAlbumsResponse|error {
        string resourcePath = string `/me/library/albums/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Album's Relationship Directly by Name
    #
    # + id - The unique identifier for the album
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/albums/[string id]/["artists"|"genres"|"library"|"record-labels"|"tracks" relationship](map<string|string[]> headers = {}, *GetAlbumRelationshipFromLibraryQueries queries) returns LibraryArtistsResponse|error {
        string resourcePath = string `/me/library/albums/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get All Library Artists
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/artists(map<string|string[]> headers = {}, *GetArtistsFromLibraryQueries queries) returns LibraryArtistsResponse|error {
        string resourcePath = string `/me/library/artists`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Artist
    #
    # + id - The unique identifier for the artist
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/artists/[string id](map<string|string[]> headers = {}, *GetArtistFromLibraryQueries queries) returns LibraryArtistsResponse|error {
        string resourcePath = string `/me/library/artists/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Artist's Relationship Directly by Name
    #
    # + id - The unique identifier for the artist
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/artists/[string id]/["albums"|"genres"|"music-videos"|"playlists"|"station" relationship](map<string|string[]> headers = {}, *GetArtistRelationshipFromLibraryQueries queries) returns LibraryAlbumsResponse|error {
        string resourcePath = string `/me/library/artists/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get All Library Songs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/songs(map<string|string[]> headers = {}, *GetSongsFromLibraryQueries queries) returns LibrarySongsResponse|error {
        string resourcePath = string `/me/library/songs`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}, "extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Song
    #
    # + id - The unique identifier for the song
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/songs/[string id](map<string|string[]> headers = {}, *GetSongFromLibraryQueries queries) returns LibrarySongsResponse|error {
        string resourcePath = string `/me/library/songs/${getEncodedUri(id)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get a Library Song's Relationship Directly by Name
    #
    # + id - The unique identifier for the song
    # + relationship - The name of the relationship you want to fetch for this resource
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - OK 
    resource isolated function get me/library/songs/[string id]/["albums"|"artists"|"composers"|"genres"|"library"|"music-videos"|"station" relationship](map<string|string[]> headers = {}, *GetSongsRelationshipFromLibraryQueries queries) returns LibrarySongsResponse|error {
        string resourcePath = string `/me/library/songs/${getEncodedUri(id)}/${getEncodedUri(relationship)}`;
        map<Encoding> queryParamEncoding = {"extend": {style: FORM, explode: true}, "include": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<anydata> headerValues = {...headers};
        headerValues["authorization"] = self.apiKeyConfig.authorization;
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }
}
